---
title: "Repatime_rsa_analyses"
output: html_document
---
## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

# set up
```{r setup, include=FALSE,  cache = FALSE, warning = TRUE, message = TRUE, error = TRUE}

# clear workspace
rm(list = ls())

#data
model='filtered100s_mtc_clean_mc_wmcsf_3sphere'
#results_dir <- sprintf("/Volumes/data/Bein/Repatime/repatime_scanner/results/encoding/rsa/no_smooth/%s/voxel_removed/FilesForR_outlier_corr_removed",model)

results_dir <- sprintf("/Users/oded/princeton_gdrive/DAVACHI_LAB/Repatime/Rfiles_data_for_JNeuro")

knitr::opts_knit$set(root.dir = results_dir)
library(tidyverse)
library(Matrix)
library(lme4)
library(lmerTest)

library(effsize)
library(ggplot2)
library(knitr)
library(reshape)
library(standardize)
library(optimx)
library(ggpubr)
library(gridExtra) #that's for the grid.arrange

#these we need for plotting models predictions
library(ggeffects)
library(sjPlot)
library(sjmisc)
library(sjstats)

#Create a custom color scale
library(RColorBrewer)
#to view the paletts:
#display.brewer.all(5)
#repetition colors - adapted:
repetition_colors <- c(rgb(1,	0.807843137254902,	0.823529411764706),
rgb(0.886274509803922,	0.305882352941177,	0.320588235294118),
rgb(0.772549019607843,	0.203921568627451,	0.217647058823529),
rgb(0.658823529411765,	0.101960784313725,	0.114705882352941),
rgb(0.35098039215686,	0,	0.0057647058823529))
 
#names(repetition_colors) <- unique(curr_data$repetition)

############# set up themes:
theme_gap <- theme_classic() +
   theme(panel.border = element_rect(color = "black", fill = NA, size = 1),
        axis.title.x = element_text(size = 18),
        axis.text.x = element_text(size = 14),
        axis.title.y = element_text(size = 18),
        strip.text = element_text(size = 14),
        title = element_text(size = 18),
        legend.text = element_text(size = 14))

theme_all_gaps <- theme_classic() +
  theme(panel.border = element_rect(color = "black", fill = NA, size = 1),
        axis.title.x = element_text(size = 26),
        axis.text.x = element_text(size = 14),
        axis.title.y = element_text(size = 26),
        strip.text = element_text(size = 18),
        title = element_text(size = 22),
        legend.text = element_text(size = 18),
        legend.title = element_blank(),
        legend.position = c(0.8, 0.2),
        legend.background = element_rect(fill= rgb(0.9,0.9,0.9)))

theme_TestRTcorr <- theme_classic() +
  theme(axis.title.x = element_text(size = 20),
        axis.text.x = element_text(size = 12),
        axis.title.y = element_text(size = 16),
        strip.text = element_text(size = 16),
        title = element_text(size = 20),
        plot.title = element_text(hjust = 0.5))

```
# reach convergence
```{r define functions}
#This was added for JNeuro revision:

reach_convergence <- function(mdl1) {
mdl2 = mdl1
x <- 1
while (length(mdl2@optinfo$conv$lme4) > 0) {
  print(sprintf('start estimating model iteration %d',x))
  pars = getME(mdl2,c("theta","fixef"))
  mdl2 <-
    update(mdl2,
           start = pars,
           control = lmerControl(optCtrl = list(maxfun = 1e5)))
  x <- x+1
  if (x > 10) {
    break
  }
}

max(
  abs(
    with(
      mdl2@optinfo$derivs, solve(Hessian, gradient)
    )
  )
)

return(mdl2)

}
```
# Load behavioral data and models
```{r load data}

setwd(results_dir)

model_encRT_data <- read.table(paste(results_dir, "behavior_models", "model_and_encoding_RTms.txt", sep="/"),header = TRUE,sep = "\t",dec = ".")
model_TempTestRT_data <- read.table(paste(results_dir, "behavior_models", "model_and_TemporalTest_quick100ms_RTms.txt", sep="/"),header = TRUE,sep = "\t",dec = ".")
model_TempTestRT_data5reps = model_TempTestRT_data[FALSE,FALSE]

#the file for Temporal test didn't include 5 reps. But, if we want to choose items from encoding RSA based on temporal_test, we need it:
#set up the temporal test, but multiply to 5 reps:
for (l in 1:6) {
  #print(sprintf("analysis for %s:",curr_roi))
  #curr_data <- model_TempTestRT_data %>% filter(list == l) #%>%
  model_TempTestRT_data5reps <- bind_rows(model_TempTestRT_data5reps , replicate(5, filter(model_TempTestRT_data, list == l), simplify = FALSE))

}
#now add the repetition
model_TempTestRT_data5reps <- mutate(model_TempTestRT_data5reps, repetition=model_encRT_data$repetition)

#load simMAT and factorise:
model_simMAT <- read.table(paste(results_dir, "behavior_models", "encoding_model_for_simMat.txt", sep="/"),header = TRUE,sep = "\t",dec = ".")

model_simMAT <- model_simMAT %>%
  mutate(fac_list = factor(model_simMAT$list),
        subID = factor(model_simMAT$subject),
        fac_rep = factor(model_simMAT$repetition), #,
        fac_event_mdl = factor(model_simMAT$event_model),
        fac_wa_control_time = factor(model_simMAT$wa_control_time),
        fac_color_mdl = factor(model_simMAT$color_model),
        fac_event_pos_item1 = factor(model_simMAT$event_pos_item1),
        fac_event_pos_item2 = factor(model_simMAT$event_pos_item2),
        position_code = factor(fac_event_pos_item1==fac_event_pos_item2),
        boundary_effect = ifelse(model_simMAT$event_pos_item1 == 1, 1,0))
  
 
```
# Interaction btw rois
### grab the data
```{r analyse entire simMAT}

#list of files - these are all the regions:
analysis_reg= "hipp"  

allfiles <- list.files(path = paste(results_dir, "/results/encoding/rsa/regions_data", sep="/"), pattern = sprintf("%s*",analysis_reg), all.files = FALSE, full.names = TRUE, recursive = FALSE)

curr_all_files=allfiles
regs=c(1,2,5,6) 

for (reg in regs ) {
curr_file=curr_all_files[reg]
fname = basename(curr_file)
#get the roi:
roi <- substr(fname,10,regexpr('_025', fname)-1) #get the roi name
hemi <- substr(fname,9,9)
print(sprintf("roi is %s, hemi is %s ",roi, hemi))

#get the data
brain_data <- read.table(curr_file, header = TRUE,sep = "\t",dec = ".")
curr_data <- bind_cols(model_simMAT, brain_data)

#remove NA:
curr_data <- filter(curr_data, !is.na(curr_data$thirdTR))

curr_data$reg_name <- roi
curr_data$hemi <- hemi
if (reg == 1) { # just bc the first one in the loop
  all_reg_data <- curr_data
} else {
  all_reg_data <- bind_rows(all_reg_data, curr_data)
}

} #ends the loop for rois
 
```
### analyse the interaction
```{r analyse the interaction}

#event_mdl_control time - within is 2, across is 1
curr_data <- filter(all_reg_data, all_reg_data$wa_control_time != 0)

#if excluding rep1:
curr_data <- filter(curr_data, curr_data$repetition > 1)

#full three-way interaction
null_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name + fac_wa_control_time*hemi + hemi*reg_name + gap + fac_list + (1|subID),curr_data,REML=F)

full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name*hemi+ gap + fac_list + (1|subID),curr_data,REML=F)

summary(full_mdl)
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))

#has an interaction of event by roi by hemi, so examine each hemi separately:
for (hemis in c('r','l')) {
  d=curr_data[curr_data$hemi == hemis,]
  
  null_mdl=lmer(thirdTR ~ fac_wa_control_time + reg_name+ gap + fac_list + (1|subID),d,REML=F)

  full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name+ gap + fac_list + (1|subID),d,REML=F)
  
  print(sprintf("#### event * roi for %s hemi: ####",hemis))
  
  summary(full_mdl)
  print(anova(full_mdl,null_mdl))
  AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
  print(sprintf("AIC diff: %.2f",AIC_diff))

}

#these analyses in each hemi revealed an interaction in the left hemi, nothing in the right hemi. so further analyses were limited to the left hemi - see next chunk.

#in Rep5, we wanted to establish that the event*roi is sig:
d=curr_data[curr_data$hemi == 'l',]
curr_rep_data <- filter(d, d$repetition == 5)

null_mdl=lmer(thirdTR ~ fac_wa_control_time + reg_name + gap + fac_list + (1|subID),curr_rep_data,REML=F)

full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name + gap + fac_list + (1|subID),curr_rep_data,REML=F)

summary(full_mdl)
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))

#by the way, the gap*event*roi is not:
null_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name + fac_wa_control_time*gap + gap*reg_name + fac_list + (1|subID),curr_rep_data,REML=F)

full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name*gap + fac_list + (1|subID),curr_rep_data,REML=F)

summary(full_mdl)
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))

## additional analyses, currently not reported:
#this is the interaction with repetition - works as well, but I don't think we need it to distinguish between hemispheres. I only report the one above, without repetition
full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name*hemi*repetition + fac_list + (1|subID),curr_data,REML=F)
drop1(full_mdl,test = "Chi")

# only 5th repetition: This also works.
curr_rep_data <- filter(curr_data, curr_data$repetition == 5)

null_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name + fac_wa_control_time*hemi + hemi*reg_name + fac_list + (1|subID),curr_rep_data,REML=F)

full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name*hemi + fac_list + (1|subID),curr_rep_data,REML=F)

summary(full_mdl)
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
 
```

# analysis per ROI:
# grab the data
```{r grab the data}
#set up:
subtract_Rep1 <- 0

analysis_reg = "hipp" 

reg=2
#lca23_025: 13
reg_univar=6 #lca3:5, ldg:6
#ldg_025: 16
#lca1_025: 11
#rca1_025: 21
model= 'filtered100s_mtc_clean_mc_wmcsf_3sphere'

#results_dir <- sprintf("/Volumes/data/Bein/Repatime/repatime_scanner/results/encoding/rsa/no_smooth/%s/voxel_removed/FilesForR_outlier_corr_removed",model)

#subtract tep1 or not
if (subtract_Rep1 == 1) {
allfiles <- list.files(path = paste(results_dir, "/results/encoding/rsa/regions_data", sep="/"), pattern = sprintf("%s*",analysis_reg), all.files = FALSE, full.names = TRUE, recursive = FALSE)

#set up the title
subRep1_ttl <- 'minus Rep1'

} else {
#this is without subtracting the first rep:
allfiles <- list.files(path = paste(results_dir, "/results/encoding/rsa/regions_data_noRep1Subtraction", sep="/"), pattern = sprintf("%s*",analysis_reg), all.files = FALSE, full.names = TRUE, recursive = FALSE)

#set up the title
subRep1_ttl <- ''
}

#take only simMAT:
#curr_all_files=allfiles[seq(3,length(allfiles), by = 4)]
curr_file=allfiles[reg]

fname = basename(curr_file)

#get the roi:
roi=substr(fname,6,regexpr('_simMat', fname)-1) #get the roi name

#get the data
brain_data <- read.table(curr_file, header = TRUE,sep = "\t",dec = ".")
curr_data <- bind_cols(model_simMAT, brain_data)

##### get univariate data:
all_univar_files <- list.files(path = paste(results_dir, "results/encoding/rsa/regions_data/univar_control", sep="/"), pattern = sprintf("%s*",analysis_reg), all.files = FALSE, full.names = TRUE, recursive = FALSE)
curr_file=all_univar_files[reg_univar]
univar_data <- read.table(curr_file, header = TRUE,sep = "\t",dec = ".")

#compute rep1 univariate from the data we have in an easy way so we can control for univariate activation
univar_data$act_item1_rep1 = univar_data$act_item1_repX - univar_data$act_item1_repX_min_rep1

univar_data$act_item2_rep1 = univar_data$act_item2_repX - univar_data$act_item2_repX_min_rep1

curr_data <- bind_cols(model_simMAT, brain_data,univar_data)

#remove NA:
curr_data <- filter(curr_data, !is.na(curr_data$thirdTR))

#scale brain data within subject:
curr_data <- curr_data %>%
   mutate(scaled_brain_bysubj = scale_by(curr_data$thirdTR ~ subID))

#save a copy:
all_data <- curr_data #just to keep some copy of that, in case we mess up with things later on

#plot the correlations:
b1 <- ggplot(all_data, aes(x=all_data$thirdTR)) + 
  geom_histogram() + 
  theme_bw() +
  labs(y = 'similarity', title ='all values')
 
curr_data <- filter(all_data, all_data$wa_control_time != 0)
 
#plot the correlations:
b2 <- ggplot(curr_data, aes(x=curr_data$thirdTR)) + 
  geom_histogram() + 
  theme_bw() +
  labs(y = 'similarity', title ='control gap values')

grid.arrange(b1, b2,ncol=2)

print(sprintf("roi is %s, %s",roi, model))


```
# CA3 and DG: temporal gap/event models - w/o response in the models
```{r temporal gap/event models}
#for dg we did more gap analyses, not needed for CA3:
analyze_gap <- 0

reps=c(2) #5
#########################
curr_data <- all_data 
curr_data$curr_gap <- curr_data$gap
curr_data$curr_brain  <- curr_data$thirdTR

#for JNeuro, had some boundary convergence:
#curr_data$curr_brain  <- curr_data$scaled_brain_bysubj #that didn't help the int by rep boundary singularity
#curr_data$curr_brain  <- scale(curr_data$thirdTR)

#wa_control_time - within is 2, across is 1
curr_data <- filter(curr_data, curr_data$wa_control_time != 0)

print(sprintf("########### analysis for %s %s #############",roi,subRep1_ttl))

if (subtract_Rep1 == 1) { #remove rep1, and don't run models with interaction by repetition

#if subtract, take it out from the data - it's a bunch of 0
curr_data <- filter(curr_data, curr_data$repetition != 1)


###### models ######
#null_model
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("event_mdl %s",roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#THIS IS IN THE PAPER FOR CA3: event model control for gap: we have different number of items per gap, important to control for that:
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_data,REML=F)

print(sprintf("event model, controling for gap %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#gap, controling for events: we have different number of items per gap, important to control for that:
null_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_data,REML=F)

print(sprintf("gap, controling for event %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


#gap and event interaction:
null_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time * curr_gap + fac_list + (1|subID),curr_data,REML=F)

print(sprintf("gap by event interaction %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

# This checks if overall the within is higher than 0 (in CA3), or the across is lower
#only WITHIN - all gaps
# curr_onlyWithOrAc_data <- filter(curr_data , curr_data$wa_control_time  == 2)
# null_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_onlyWithOrAc_data,REML=F)
# print(sprintf("only WITHIN, check the intercept %s",roi))
# print(summary(null_mdl))
# 
# #only ACROSS - all gaps
# curr_onlyWithOrAc_data <- filter(curr_data , curr_data$wa_control_time  == 1)
# null_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_onlyWithOrAc_data,REML=F)
# print(sprintf("only ACROSS, check the intercept  %s",roi))
# print(summary(null_mdl))

  if (analyze_gap == 1) {
  onlyWithOrAc_data <- filter(curr_data , curr_data$wa_control_time  == 2)
  null_mdl=lmer(curr_brain ~ fac_list + (1|subID),onlyWithOrAc_data,REML=F)
  gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),onlyWithOrAc_data,REML=F)
  print(sprintf("only WITHIN, main effect of gap, %s", roi))
  print(anova(gap_mdl,null_mdl))
  AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
  print(sprintf("AIC diff: %.2f",AIC_diff))
  print("")
  
  onlyWithOrAc_data <- filter(curr_data , curr_data$wa_control_time  == 1)
  null_mdl=lmer(curr_brain ~ fac_list + (1|subID),onlyWithOrAc_data,REML=F)
  gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),onlyWithOrAc_data,REML=F)
  print(sprintf("only ACROSS, main effect of gap, %s", roi))
  print(anova(gap_mdl,null_mdl))
  AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
  print(sprintf("AIC diff: %.2f",AIC_diff))
  print("")
  }


} else { #did not subtract rep1 - run interaction by repetition
  
#event by repetition
#that's reported for CA3:
print(sprintf("event by repetition interaction, gap in the model %s", roi))
null_mdl=lmer(curr_brain ~ fac_wa_control_time + repetition + curr_gap + fac_list + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time*repetition + curr_gap + fac_list + (1|subID),curr_data,REML=F)

print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")
print(summary(full_mdl))


#For CA3, had boundary convergence ran these,and the ANOVA below:
#diff_optims <- allFit(full_mdl, maxfun = 1e5)
#new_full_mdl <- reach_convergence(full_mdl)

#gap by repetition
#that's reported for CA1:
print(sprintf("gap by repetition interaction,event in the model %s", roi))
null_mdl=lmer(curr_brain ~ fac_wa_control_time + repetition + curr_gap + fac_list + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + repetition * curr_gap + fac_list + (1|subID),curr_data,REML=F)

print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")
print(summary(full_mdl))
#For CA3, had boundary convergence ran these, and the ANOVA below:
#diff_optims <- allFit(full_mdl, maxfun = 1e5)
#new_full_mdl <- reach_convergence(full_mdl)


#event_mdl_control time by temporal gap by repetition - within is 2, across is 1
#that's reported for DG:
print(sprintf("gap by event by repetition interaction %s", roi))
null_mdl=lmer(curr_brain ~ fac_wa_control_time*curr_gap+curr_gap*repetition + fac_wa_control_time*repetition + fac_list + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time*curr_gap*repetition + fac_list + (1|subID),curr_data,REML=F)

print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")
print(summary(full_mdl))
#For CA3, had boundary convergence ran these:
#diff_optims <- allFit(full_mdl, maxfun = 1e5)
#new_full_mdl <- reach_convergence(full_mdl)
print(sprintf("gap by event by repetition interaction ANOVA %s", roi))
curr_data_average <- curr_data %>%
  group_by(subID,fac_wa_control_time,curr_gap,repetition) %>%
  summarize(curr_brain = mean(curr_brain, na.rm = TRUE))

print(summary(aov(curr_brain ~ fac_wa_control_time*curr_gap*repetition + Error(subID/fac_wa_control_time*curr_gap*repetition), data = curr_data_average)))



} #close the Rep1 if

if (subtract_Rep1 == 1) { #remove rep1, can analyze each rep separately
  

for ( r in reps) {
print(sprintf("################# rep %d ####################",r))
curr_rep_data <- filter(curr_data,curr_data$repetition == r)

print(sprintf("REP %d: event_mdl %s",r, roi))
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_rep_data,REML=F)

print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#event model control for gap: we have different number of items per gap, important to control for that: *this is reported for CA3*
print(sprintf("REP %d: event_mdl controling for gap %s",r, roi))
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)

print(summary(full_mdl))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#For rep2 in CA3, had convergence issues, ran these:
diff_optims <- allFit(full_mdl, maxfun = 1e5)
new_full_mdl <- reach_convergence(full_mdl)


print(sprintf("event t-test %s", roi))
curr_data_average <- curr_rep_data %>%
  group_by(subID,fac_wa_control_time) %>%
  summarize(curr_brain = mean(curr_brain, na.rm = TRUE))

res_t <- t.test(curr_brain ~ fac_wa_control_time, data = curr_data_average, paired = TRUE)
print(res_t)


#gap, controling for events: we have different number of items per gap, important to control for that:
print(sprintf("REP %d: gap, controling for event %s",r, roi))
null_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_rep_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)

print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#gap and event interaction:
print(sprintf("REP %d: gap by event interaction %s",r, roi))
null_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time * curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)

print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#For rep2 and rep5 in DG, had boundary singlar fit, ran these:
print(summary(full_mdl))
#diff_optims <- allFit(full_mdl, maxfun = 1e5)
#new_full_mdl <- reach_convergence(full_mdl)

print(sprintf("REP %d: gap by event interaction %s ANOVA",r, roi))
curr_data_average <- curr_rep_data %>%
  group_by(subID,fac_wa_control_time,curr_gap) %>%
  summarize(curr_brain = mean(curr_brain, na.rm = TRUE))

print(summary(aov(curr_brain ~ fac_wa_control_time*curr_gap + Error(subID/fac_wa_control_time*curr_gap), data = curr_data_average)))


if (analyze_gap == 1) {
#only WITHIN - all gaps
curr_rep_onlyWithOrAc_data <- filter(curr_rep_data , curr_rep_data$wa_control_time  == 2)
print(sprintf("only WITHIN, main effect of gap, rep %d, %s",r, roi))
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)

print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#For rep2 and rep5 in DG, had boundary singlar fit, ran these:
print(summary(gap_mdl))
#diff_optims <- allFit(gap_mdl, maxfun = 1e5)
#new_full_mdl <- reach_convergence(gap_mdl)

print(sprintf("only WITHIN, main effect of gap, rep %d, %s ANOVA",r, roi))
curr_data_average <- curr_rep_onlyWithOrAc_data %>%
  group_by(subID,curr_gap) %>%
  summarize(curr_brain = mean(curr_brain, na.rm = TRUE))

print(summary(aov(curr_brain ~ curr_gap + Error(subID/curr_gap), data = curr_data_average)))


#only within - gaps 1-2
curr_rep_selgap <- filter(curr_rep_onlyWithOrAc_data ,
                                  curr_rep_onlyWithOrAc_data$gap  < 3)
print(sprintf("only WITHIN, gap 1-2, rep %d,  %s",r, roi))
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_selgap,REML=F)

print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#For rep2 and rep5 in DG, had boundary singlar fit, ran these:
print(summary(gap_mdl))
#diff_optims <- allFit(gap_mdl, maxfun = 1e5)
#new_full_mdl <- reach_convergence(gap_mdl)

#t-test:
print("only WITHIN, gap 1-2, t-test")
curr_data_average <- curr_rep_selgap %>%
  group_by(subID,curr_gap) %>%
  summarize(curr_brain = mean(curr_brain, na.rm = TRUE))

res_t <- t.test(curr_brain ~ curr_gap, data = curr_data_average, paired = TRUE)
print(res_t)

#only within - gaps 1-3
curr_rep_selgap <- filter(curr_rep_onlyWithOrAc_data ,
                                  curr_rep_onlyWithOrAc_data$gap  != 2)
print(sprintf("only WITHIN, gap 1-3, rep %d,  %s",r, roi))
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_selgap,REML=F)

print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#For rep2 and rep5 in DG these models were fine.
print(summary(gap_mdl))
#diff_optims <- allFit(gap_mdl, maxfun = 1e5)
#new_full_mdl <- reach_convergence(gap_mdl)

#only ACROSS - all gaps
curr_rep_onlyWithOrAc_data <- filter(curr_rep_data , curr_rep_data$wa_control_time  == 1)
print(sprintf("only ACROSS, main effect of gap, rep %d, %s",r, roi))
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)

print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#For rep2 and rep5 in DG, had boundary singlar fit, ran these:
print(summary(gap_mdl))
#diff_optims <- allFit(gap_mdl, maxfun = 1e5)
#new_full_mdl <- reach_convergence(gap_mdl)

print(sprintf("only ACROSS, main effect of gap, rep %d, %s ANOVA",r, roi))
curr_data_average <- curr_rep_onlyWithOrAc_data %>%
  group_by(subID,curr_gap) %>%
  summarize(curr_brain = mean(curr_brain, na.rm = TRUE))

print(summary(aov(curr_brain ~ curr_gap + Error(subID/curr_gap), data = curr_data_average)))

#only ACROSS - gaps 1-2
curr_rep_selgap <- filter(curr_rep_onlyWithOrAc_data ,
                                  curr_rep_onlyWithOrAc_data$gap  < 3)
print(sprintf("only ACROSS, gap 1-2, rep %d,  %s",r, roi))
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_selgap,REML=F)

print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#For rep2 and rep5 in DG, had boundary singlar fit, ran these:
print(summary(gap_mdl))
#diff_optims <- allFit(gap_mdl, maxfun = 1e5)
#new_full_mdl <- reach_convergence(gap_mdl)

#t-test:
print("only ACROSS, gap 1-2, t-test")
curr_data_average <- curr_rep_selgap %>%
  group_by(subID,curr_gap) %>%
  summarize(curr_brain = mean(curr_brain, na.rm = TRUE))

res_t <- t.test(curr_brain ~ curr_gap, data = curr_data_average, paired = TRUE)
print(res_t)

#only ACROSS - gaps 1-3
curr_rep_selgap <- filter(curr_rep_onlyWithOrAc_data ,
                                  curr_rep_onlyWithOrAc_data$gap  != 2)
print(sprintf("only ACROSS, gap 1-3, rep %d,  %s",r, roi))
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_selgap,REML=F)

print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#For rep2 and rep5 in DG, these were fine.
print(summary(gap_mdl))
#diff_optims <- allFit(gap_mdl, maxfun = 1e5)
#new_full_mdl <- reach_convergence(gap_mdl)

#for JNeuro: compare gap of 1/2/3, within vs. across:
#all_gaps <- c(1,2,3)
#for (curr_gap in all_gaps) {
  
  curr_rep_curr_gap <- filter(curr_rep_data , curr_rep_data$gap == 1)
  #print(nrow(curr_rep_curr_gap))
  print(sprintf(" gap 1: compare within vs. across, rep %d,  %s",r, roi))
  null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_curr_gap,REML=F)
  full_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_rep_curr_gap,REML=F)
  
  print(anova(full_mdl,null_mdl))
  AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
  print(sprintf("AIC diff: %.2f",AIC_diff))
  print("")
  
  print(summary(full_mdl))
  #diff_optims <- allFit(full_mdl, maxfun = 1e5)
  #new_full_mdl <- reach_convergence(full_mdl)
  
  #t-test:
  print("gap 1: compare within vs. across, t-test")
  curr_data_average <- curr_rep_curr_gap %>%
    group_by(subID,fac_wa_control_time) %>%
    summarize(curr_brain = mean(curr_brain, na.rm = TRUE))
  
  res_t <- t.test(curr_brain ~ fac_wa_control_time, data = curr_data_average, paired = TRUE)
  print(res_t)
  
  

  curr_rep_curr_gap <- filter(curr_rep_data , curr_rep_data$gap == 2)
  #print(nrow(curr_rep_curr_gap))
  print(sprintf(" gap 2: compare within vs. across, rep %d,  %s",r, roi))
  null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_curr_gap,REML=F)
  full_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_rep_curr_gap,REML=F)
  
  
  print(anova(full_mdl,null_mdl))
  AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
  print(sprintf("AIC diff: %.2f",AIC_diff))
  print("")
  
  print(summary(full_mdl))
  #diff_optims <- allFit(full_mdl, maxfun = 1e5)
  #new_full_mdl <- reach_convergence(full_mdl)
  #t-test:
  print("gap 2: compare within vs. across, t-test")
  curr_data_average <- curr_rep_curr_gap %>%
    group_by(subID,fac_wa_control_time) %>%
    summarize(curr_brain = mean(curr_brain, na.rm = TRUE))
  
  res_t <- t.test(curr_brain ~ fac_wa_control_time, data = curr_data_average, paired = TRUE)
  print(res_t)
  
  curr_rep_curr_gap <- filter(curr_rep_data , curr_rep_data$gap == 3)
  #print(nrow(curr_rep_curr_gap))
  print(sprintf(" gap 3: compare within vs. across, rep %d,  %s",r, roi))
  null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_curr_gap,REML=F)
  full_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_rep_curr_gap,REML=F)
  
  print(anova(full_mdl,null_mdl))
  AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
  print(sprintf("AIC diff: %.2f",AIC_diff))
  print("")
  
  print(summary(full_mdl))
  diff_optims <- allFit(full_mdl, maxfun = 1e5)
  new_full_mdl <- reach_convergence(full_mdl)

#}

} #end the analyse_gap

} #end the repetition
  
} #ends the subtract rep1


```


## plot similarity events/gap (main data figures)
```{r plot gap from entire simMAT}

curr_data <- all_data 
#curr_data$curr_brain  <- curr_data$thirdTR

#plot only control time:
data_wa_control_time <- filter(curr_data, curr_data$wa_control_time != 0)
# if (subtract_Rep1 == 1) {
#   #remove Rep1, don't want to plot it.
# data_wa_control_time <- filter(data_wa_control_time, data_wa_control_time$repetition != 1)
# }


summary_gap_event_model_control_time_rep <- data_wa_control_time %>%
  group_by(subID, gap, fac_wa_control_time, repetition ) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE))
summary_gap_event_model_control_time_rep$fac_gap <- factor(summary_gap_event_model_control_time_rep$gap)

sum_data <- summary_gap_event_model_control_time_rep %>%
  group_by(gap, fac_wa_control_time, repetition ) %>%
  summarize(mean_sim = mean(mean_sim, na.rm = TRUE))

#onlly rep5:
data_wa_control_time_rep5 <- filter(data_wa_control_time, data_wa_control_time$repetition == 5)

summary_gap_event_model_control_time_rep5 <- data_frame(data_wa_control_time_rep5 %>%
  group_by(subID, gap, fac_wa_control_time ) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE)))


mean_gap_event_model_control_time_rep5 <- data_frame(summary_gap_event_model_control_time_rep5 %>%
  group_by(gap, fac_wa_control_time ) %>%
  summarize(mean_sim = mean(mean_sim, na.rm = TRUE)))


summary_only_event_model_control_time_rep5 <- data_wa_control_time_rep5 %>%
  group_by(subID, fac_wa_control_time ) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE))

data_wa_diff_per_subj <- summary_only_event_model_control_time_rep5 %>%
  pivot_wider(names_from = fac_wa_control_time, values_from = mean_sim)
data_wa_diff_per_subj$wa_diff <- data_wa_diff_per_subj$'2'-data_wa_diff_per_subj$'1'

#for DG, to plot the spread of the participants - try doing the interaction:
#- two columns, one for within, and one for across, each shows the difference of gap1-gap3
data_only_g1g3 <- filter(summary_gap_event_model_control_time_rep5,summary_gap_event_model_control_time_rep5$gap != 2) %>%
  pivot_wider(names_from = gap, values_from = mean_sim)
data_only_g1g3$g1g3_diff <- data_only_g1g3$'1'-data_only_g1g3$'3'


########### actually plot things ###########
all_spectral<-brewer.pal(11,"RdYlBu")
myspec_within <-all_spectral[c(2,3,4)]
#myspec_across <-all_spectral[c(10,9,8)] #blues
all_spectral<-brewer.pal(9,"Greys")
myspec_across <-all_spectral[c(4,5,6)] #greys
myspec <-c(myspec_across[2],myspec_within[2])

#plot event by gap by rep - don't plot rep1
labels_rep <- c(
  "1" = "Repetition 1",
  "2" = "Repetition 2",
  "3" = "Repetition 3",
  "4" = "Repetition 4",
  "5" = "Repetition 5"
)

labels_gap <- c(
  "1" = "Gap1",
  "2" = "Gap2",
  "3" = "Gap3"
)

labels_wa <- c(
  "1" = "across",
  "2" = "within"
)

#this fig. is in the supp
all_reps_p <- ggplot(summary_gap_event_model_control_time_rep, aes(x = gap, y = mean_sim)) +
  stat_summary(data = summary_gap_event_model_control_time_rep, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
  labs(x = 'Temporal Distance', y = sprintf('Similarity %s', subRep1_ttl)) +
  scale_color_manual(values = myspec) +
  facet_grid(~repetition,labeller = labeller(repetition = labels_rep)) + 
  theme_all_gaps + theme(legend.position = "none") 

print(all_reps_p)

#coord_cartesian(ylim = c(-.018,.023)) +
#this fig is for the main figures:
rep5 <- ggplot(summary_gap_event_model_control_time_rep5, aes(x = gap, y = mean_sim)) +
  stat_summary(data = summary_gap_event_model_control_time_rep5, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
  labs(x = 'Gap', y = 'Similarity (Rep5 minus Rep1)') +
  scale_color_manual(values = myspec) +
  scale_x_continuous(breaks = c(1,2,3),labels=c(0,1,2)) +
  theme_gap + theme(legend.position = "none") 

print(rep5)

#for CA3, only within vs, across:
rep5_wa <- ggplot(summary_only_event_model_control_time_rep5, aes(x = 1, y = mean_sim)) +
  stat_summary(data = summary_only_event_model_control_time_rep5, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
  labs(y = 'Similarity (Rep5 minus Rep1)') +
  scale_color_manual(values = myspec) +
  coord_cartesian(ylim = c(-.012,.012)) +
  scale_x_continuous(breaks = c(1,2,3),labels=c(0,1,2)) +
  theme_classic() + theme(legend.position = "none",
                    axis.title.x = element_blank(),
                    axis.text.x = element_blank(),
                    axis.ticks.x = element_blank(),
                    axis.line.x = element_blank(),
                    axis.title.y = element_text(size = 16)) 

#for CA3, only within vs, across with subj data points:
# geom_violin(data = data_wa_diff_per_subj,aes(x = "1", y = wa_diff, alpha = .4))
plt_CA3_subj_con <- ggplot(data_wa_diff_per_subj, aes(x = 1, y = wa_diff, color = "1")) +
  stat_summary(data = data_wa_diff_per_subj, fun.data = mean_se_, geom = "pointrange",aes(color = "1"), position_dodge(width = .9),size=1) +
  geom_hline(yintercept=0, colour="black", linetype = "dotted") +
  xlim(0.7,1.3) +
  geom_jitter(width = .08,size = 2,shape = 1) + 
  scale_color_manual(values = myspec[2]) +
  labs(y = 'Similarity\n(within > across)') + 
  theme_classic() + theme(legend.position = "none",
                          axis.title.x = element_blank(),
                          axis.text.x = element_blank(),
                          axis.line.x = element_blank(),
                          axis.ticks.x = element_blank(),
                          axis.title.y = element_text(size = 16))

grid.arrange(rep5_wa,plt_CA3_subj_con,widths = c(1.8,1),ncol = 2)

#for DG - show the spread of the interaction 
plt_DG_subj_con <- ggplot(data_only_g1g3, aes(x = fac_wa_control_time, y = g1g3_diff, color = fac_wa_control_time)) +
  geom_hline(yintercept=0, colour="black", linetype = "dotted") +
  stat_summary(data = data_only_g1g3, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
  geom_jitter(width = .15,size = 2,shape = 1) + 
  scale_color_manual(values = myspec) +
  labs(y = 'Temporal separation\n(temporal distance 1 minus 3)') + 
  theme_classic() + theme(legend.position = "none",
                          axis.title.x = element_blank(),
                          axis.text.x = element_blank(),
                          axis.line.x = element_blank(),
                          axis.ticks.x = element_blank(),
                          axis.title.y = element_text(size = 14))

#grid.arrange(rep5,plt_DG_subj_con,widths = c(1.8,1),ncol = 2)


#stat_summary(data = data_only_g1g3, fun.data = mean_se_, geom = "pointrange",aes(x = fac_wa_control_time, y = g1g3_diff, color = fac_wa_control_time), position_dodge(width = .9),size=1) +
  #geom_jitter(width = .08,size = 2,shape = 1) + 
 # geom_point() + geom_line() +

#for DG - show the spread of the interaction - this is me starting to do something with connecting the dots...:
#doesn't look too good...
data_only_g1g3_jit <- data_only_g1g3 %>%
  mutate(jit_wa = jitter(as.numeric(fac_wa_control_time),amount = .1))
plt_DG_subj_con <- ggplot(data_only_g1g3_jit, aes(x = jit_wa, y = g1g3_diff, color = fac_wa_control_time)) +
  geom_hline(yintercept=0, colour="black", linetype = "dotted") +
  scale_color_manual(values = myspec) +
  geom_path(aes(group = factor(subID)), color='grey',size=0.4) +
  geom_point(size = 2,shape = 1) +
  labs(y = 'Temporal separation\n(temporal distance 1 minus 3)') + 
  theme_classic() + theme(legend.position = "none",
                          axis.title.x = element_blank(),
                          #axis.text.x = element_blank(),
                          #axis.line.x = element_blank(),
                          #axis.ticks.x = element_blank(),
                          axis.title.y = element_text(size = 14))

#additional data plots:
rep5_with_subj_dots <- ggplot(summary_gap_event_model_control_time_rep5, aes(x = gap, y = mean_sim)) +
  stat_summary(data = summary_gap_event_model_control_time_rep5, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
  geom_point(aes(color = fac_wa_control_time), position = position_jitterdodge(dodge.width = 0.9), alpha = .8,size=2) +
  labs(x = 'Temporal Distance', y = 'Similarity (Rep5 minus Rep1)') +
  scale_color_manual(values = myspec) +
  theme_gap + theme(legend.position = "none") 


#geom_hline(yintercept=0, color="black", linetype = "dotted") +
all_reps_p_by_wa <- ggplot(summary_gap_event_model_control_time_rep, aes(x = repetition, y = mean_sim,color = fac_wa_control_time, alpha = fac_gap)) + 
  stat_summary(data = summary_gap_event_model_control_time_rep, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time,alpha = fac_gap), position_dodge(width = .9),size=1) +
  labs(x = 'Repetition', y = 'similarity (thirdTR)', title = roi) +
  scale_alpha_discrete(range = c(1,0.4),
                       name=NULL,
                       breaks=c("1", "2","3"),
                       labels=c("Gap1","Gap2","Gap3")) +
  scale_color_manual(values = myspec,
                       name=NULL,
                       breaks=c("1", "2"),
                       labels=c("across-events","within-event")) +
  facet_grid(~fac_wa_control_time,labeller = labeller(fac_wa_control_time = labels_wa)) + 
  theme_all_gaps + theme(legend.position = NULL)
print(all_reps_p_by_wa)

#just plot gap:
# all_reps_gap <- ggplot(summary_gap_event_model_control_time_rep, aes(x = gap, y = mean_sim)) +
#   stat_summary(data = summary_gap_event_model_control_time_rep, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
#   labs(x = 'Gap', y = 'Similarity (Diff. from Rep1)') +
#   scale_color_manual(values = myspec) +
#   scale_x_continuous(breaks = c(1,2,3),labels=c(0,1,2)) +
#   facet_grid(~repetition,labeller = labeller(repetition = labels_rep)) + 
#   theme_all_gaps + theme(legend.position = "none") 
# 
# print(all_reps_p)
```

# CA3 and DG: control for UNIVARIATE ACTIVATION, temporal gap/event models
```{r temporal gap/event models}
# This part I did based on what is reported in the paper - for additional analyses, see the block above of the analysis w/o controling for univariate activation

#for dg we did more gap analyses, not needed for CA3:
analyze_gap <- 1

reps=c(5)

#########################
curr_data <- all_data 
curr_data$curr_gap <- curr_data$gap
curr_data$curr_brain  <- curr_data$thirdTR

#if want to exclude rep1
#curr_data <- filter(curr_data, curr_data$repetition != 1)


###### models ######
print(sprintf("########### analysis for %s %s #############",roi,subRep1_ttl))

#wa_control_time - within is 2, across is 1
curr_data <- filter(curr_data, curr_data$wa_control_time != 0)
#null_model
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("event_mdl %s",roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#event model control for gap: we have different number of items per gap, important to control for that:
#that's reported for CA3, as the main effect of within vs. across, all reps:
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_data,REML=F)

print(sprintf("event model, controling for gap %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#Same, controlling for univar - the difference from rep1 :
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_data,REML=F)

print(sprintf("event model, controling for gap %s CONTROL UNIVAR diff from rep 1", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#Same, controlling for univar - raw data (i.e. not the difference from rep1):
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_data,REML=F)

print(sprintf("event model, controling for gap %s CONTROL UNIVAR raw", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


#Same, controlling for univar - raw data (i.e. not the difference from rep1):
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),curr_data,REML=F)

print(sprintf("event model, controling for gap %s CONTROL UNIVAR Rep1", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

# main effect of gap:
#that's reported for CA3 (no main effect of temporal distance, no need to control for univar):
null_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_data,REML=F)

print(sprintf("gap, controling for event %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#gap and event interaction:
#CA3: no interaction, no need to control for univar:
#DG: sig. interaction, control for univar
null_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time * curr_gap + fac_list + (1|subID),curr_data,REML=F)

print(sprintf("gap by event interaction %s ", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#Same, controlling for univar - the difference from rep1 :
null_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time * curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_data,REML=F)

print(sprintf("gap by event interaction %s CONTROL UNIVAR diff from rep 1", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#Same, controlling for univar - raw activation :
null_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time * curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_data,REML=F)

print(sprintf("gap by event interaction %s CONTROL UNIVAR raw data", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#event by repetition
#that's reported for CA3 - marginal:
null_mdl=lmer(curr_brain ~ fac_wa_control_time + repetition + curr_gap + fac_list + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time*repetition + curr_gap + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("event by repetition interaction, gap in the model %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#Same, controlling for univar - the difference from rep1:
null_mdl=lmer(curr_brain ~ fac_wa_control_time + repetition + curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time*repetition + curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_data,REML=F)
print(sprintf("event by repetition interaction, gap in the model %s CONTROL UNIVAR diff from rep1", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#Same, controlling for univar - raw univar:
null_mdl=lmer(curr_brain ~ fac_wa_control_time + repetition + curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time*repetition + curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_data,REML=F)
print(sprintf("event by repetition interaction, gap in the model %s CONTROL UNIVAR raw data", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#Same, controlling for univar - raw univar:
null_mdl=lmer(curr_brain ~ fac_wa_control_time + repetition + curr_gap + fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time*repetition + curr_gap + fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),curr_data,REML=F)
print(sprintf("event by repetition interaction, gap in the model %s CONTROL UNIVAR rep1", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#gap by repetition
#that's reported for CA1:
null_mdl=lmer(curr_brain ~ fac_wa_control_time + repetition + curr_gap + fac_list + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + repetition * curr_gap + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("gap by repetition interaction,event in the model %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#event_mdl_control time by temporal gap by repetition - within is 2, across is 1
#that's reported for DG (sig., report univar control) and for CA3 (not sig.):
null_mdl=lmer(curr_brain ~ fac_wa_control_time*curr_gap+curr_gap*repetition + fac_wa_control_time*repetition + fac_list + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time*curr_gap*repetition + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("gap by event by repetition interaction %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#Same, controlling for univar - the difference from rep1:
null_mdl=lmer(curr_brain ~ fac_wa_control_time*curr_gap+curr_gap*repetition + fac_wa_control_time*repetition + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time*curr_gap*repetition + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_data,REML=F)
print(sprintf("gap by event by repetition interaction %s CONTROL UNIVAR diff from rep1", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#Same, controlling for univar - raw:
null_mdl=lmer(curr_brain ~ fac_wa_control_time*curr_gap+curr_gap*repetition + fac_wa_control_time*repetition + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time*curr_gap*repetition + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_data,REML=F)
print(sprintf("gap by event by repetition interaction %s CONTROL UNIVAR raw (i.e., not diff from rep1)", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#Same, controlling for univar - rep1:
null_mdl=lmer(curr_brain ~ fac_wa_control_time*curr_gap+curr_gap*repetition + fac_wa_control_time*repetition + fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time*curr_gap*repetition + fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),curr_data,REML=F)
print(sprintf("gap by event by repetition interaction %s CONTROL UNIVAR rep1", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


if (analyze_gap == 1) {
  #reported for DG (sig., control for univar):
  onlyWithOrAc_data <- filter(curr_data , curr_data$wa_control_time  == 2)
  null_mdl=lmer(curr_brain ~ fac_list + (1|subID),onlyWithOrAc_data,REML=F)
  gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),onlyWithOrAc_data,REML=F)
  print(sprintf("only WITHIN, main effect of gap, %s", roi))
  print(anova(gap_mdl,null_mdl))
  AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
  print(sprintf("AIC diff: %.2f",AIC_diff))
  print("")
  
  #Same, controlling for univar - the difference from rep1:
  null_mdl=lmer(curr_brain ~ fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),onlyWithOrAc_data,REML=F)
  gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),onlyWithOrAc_data,REML=F)
  print(sprintf("only WITHIN, main effect of gap, %s CONTROL UNIVAR diff from rep1", roi))
  print(anova(gap_mdl,null_mdl))
  AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
  print(sprintf("AIC diff: %.2f",AIC_diff))
  print("")
  
  #Same, controlling for univar - raw vals:
  null_mdl=lmer(curr_brain ~ fac_list + act_item1_repX*act_item2_repX + (1|subID),onlyWithOrAc_data,REML=F)
  gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),onlyWithOrAc_data,REML=F)
  print(sprintf("only WITHIN, main effect of gap, %s CONTROL UNIVAR raw", roi))
  print(anova(gap_mdl,null_mdl))
  AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
  print(sprintf("AIC diff: %.2f",AIC_diff))
  print("")
  
   #Same, controlling for univar - rep1:
  null_mdl=lmer(curr_brain ~ fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),onlyWithOrAc_data,REML=F)
  gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),onlyWithOrAc_data,REML=F)
  print(sprintf("only WITHIN, main effect of gap, %s CONTROL UNIVAR rep1", roi))
  print(anova(gap_mdl,null_mdl))
  AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
  print(sprintf("AIC diff: %.2f",AIC_diff))
  print("")
  
  #reported for DG (non sig., no need to control for univar):
  onlyWithOrAc_data <- filter(curr_data , curr_data$wa_control_time  == 1)
  null_mdl=lmer(curr_brain ~ fac_list + (1|subID),onlyWithOrAc_data,REML=F)
  gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),onlyWithOrAc_data,REML=F)
  print(sprintf("only ACROSS, main effect of gap, %s", roi))
  print(anova(gap_mdl,null_mdl))
  AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
  print(sprintf("AIC diff: %.2f",AIC_diff))
  print("")
}

for ( r in reps) {
print(sprintf("################# rep %d ####################",r))
curr_rep_data <- filter(curr_data,curr_data$repetition == r)

null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_rep_data,REML=F)
print(sprintf("REP %d: event_mdl %s",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#event model control for gap: we have different number of items per gap, important to control for that: *this is reported for CA3, significant in rep5, not in rep2*, not reported for DG.
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)

print(sprintf("REP %d: event_mdl controling for gap %s",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, diff from rep 1: 
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_rep_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_rep_data,REML=F)

print(sprintf("REP %d: event_mdl controling for gap %s CONTROL UNIVAR diff from rep 1",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, raw (i.e., not diff from rep 1): 
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_data,REML=F)

print(sprintf("REP %d: event_mdl controling for gap %s CONTROL UNIVAR raw",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


#same, controlling for univar, rep 1: 
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),curr_rep_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),curr_rep_data,REML=F)

print(sprintf("REP %d: event_mdl controling for gap %s CONTROL UNIVAR Rep1",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#gap, controling for events: 
null_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_rep_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)

print(sprintf("REP %d: gap, controling for event %s",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#gap and event interaction:
#this is reported for DG, report univar control.
null_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time * curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)

print(sprintf("REP %d: gap by event interaction %s",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, diff from rep 1: 
null_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_rep_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time * curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_rep_data,REML=F)

print(sprintf("REP %d: gap by event interaction %s CONTROL UNIVAR diff from rep 1",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, raw: 
null_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time * curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_data,REML=F)

print(sprintf("REP %d: gap by event interaction %s CONTROL UNIVAR  raw",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


#same, controlling for univar, rep1: 
null_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),curr_rep_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time * curr_gap + fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),curr_rep_data,REML=F)

print(sprintf("REP %d: gap by event interaction %s CONTROL UNIVAR  Rep1",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


if (analyze_gap == 1) {
#only WITHIN - all gaps
curr_rep_onlyWithOrAc_data <- filter(curr_rep_data , curr_rep_data$wa_control_time  == 2)
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
print(sprintf("only WITHIN, main effect of gap, rep %d, %s ",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, diff from rep 1: 
null_mdl=lmer(curr_brain ~ fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
print(sprintf("only WITHIN, main effect of gap, rep %d, %s CONTROL UNIVAR  diff from rep1",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, raw: 
null_mdl=lmer(curr_brain ~ fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
print(sprintf("only WITHIN, main effect of gap, rep %d, %s CONTROL UNIVAR  raw",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, raw: 
null_mdl=lmer(curr_brain ~ fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
print(sprintf("only WITHIN, main effect of gap, rep %d, %s CONTROL UNIVAR rep1",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


#only within - gaps 1-2
curr_rep_selgap <- filter(curr_rep_onlyWithOrAc_data ,
                                  curr_rep_onlyWithOrAc_data$gap  < 3)
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_selgap,REML=F)
print(sprintf("only WITHIN, gap 1-2, rep %d,  %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, diff from rep 1: 
null_mdl=lmer(curr_brain ~ fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_rep_selgap,REML=F)
print(sprintf("only WITHIN, gap 1-2, rep %d,  %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, raw: 
null_mdl=lmer(curr_brain ~ fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_selgap,REML=F)
print(sprintf("only WITHIN, gap 1-2, rep %d,  %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


#only within - gaps 1-3
curr_rep_selgap <- filter(curr_rep_onlyWithOrAc_data ,
                                  curr_rep_onlyWithOrAc_data$gap  != 2)
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_selgap,REML=F)
print(sprintf("only WITHIN, gap 1-3, rep %d,  %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, diff from rep 1: 
null_mdl=lmer(curr_brain ~ fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_rep_selgap,REML=F)
print(sprintf("only WITHIN, gap 1-3, rep %d,  %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, raw: 
null_mdl=lmer(curr_brain ~ fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_selgap,REML=F)
print(sprintf("only WITHIN, gap 1-3, rep %d,  %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#only ACROSS - all gaps reported for Dg, but not sig., no need to control for univar
curr_rep_onlyWithOrAc_data <- filter(curr_rep_data , curr_rep_data$wa_control_time  == 1)

null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
print(sprintf("only ACROSS, main effect of gap, rep %d, %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#only ACROSS - gaps 1-2
curr_rep_selgap <- filter(curr_rep_onlyWithOrAc_data ,
                                  curr_rep_onlyWithOrAc_data$gap  < 3)
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_selgap,REML=F)
print(sprintf("only ACROSS, gap 1-2, rep %d,  %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#only ACROSS - gaps 1-3
curr_rep_selgap <- filter(curr_rep_onlyWithOrAc_data ,
                                  curr_rep_onlyWithOrAc_data$gap  != 2)
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_selgap,REML=F)
print(sprintf("only ACROSS, gap 1-3, rep %d,  %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#for JNeuro: compare gap of 1, within vs. across:
curr_rep_only_gap1 <- filter(curr_rep_data , curr_rep_data$gap  == 1)

null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_only_gap1,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_rep_only_gap1,REML=F)

print(sprintf(" gap 1, compare within vs. across, rep %d,  %s",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, diff from rep 1: 
null_mdl=lmer(curr_brain ~ fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_rep_only_gap1,REML=F)
gap_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + act_item1_repX_min_rep1*act_item2_repX_min_rep1 + (1|subID),curr_rep_only_gap1,REML=F)
print(sprintf(" gap 1, compare within vs. across, rep %d,  %s CONTROL UNIVAR diff from rep1",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, raw: 
null_mdl=lmer(curr_brain ~ fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_only_gap1,REML=F)
gap_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + act_item1_repX*act_item2_repX + (1|subID),curr_rep_only_gap1,REML=F)
print(sprintf(" gap 1, compare within vs. across, rep %d,  %s CONTROL UNIVAR raw",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#same, controlling for univar, rep1: 
null_mdl=lmer(curr_brain ~ fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),curr_rep_only_gap1,REML=F)
gap_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + act_item1_rep1*act_item2_rep1 + (1|subID),curr_rep_only_gap1,REML=F)
print(sprintf(" gap 1, compare within vs. across, rep %d,  %s CONTROL UNIVAR rep1",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


} #end the analyse_gap

} #end the repetition


```
# CA3 correlations with ENCODING RT
##### edit the full matrix model
```{r edit the all matrix model}
#grabs the matrix model and encoding RTs and place encoding RTs for each pair.
fc_rep <- 0 #use linear
t_per_list <- 24
tot_reps <- 5

if (fc_rep == 1) {
model_simMAT <- model_simMAT %>%
  mutate(fac_rep = factor(repetition))
} else {
  model_simMAT <- model_simMAT %>%
  mutate(fac_rep = scale(repetition))
}

model_simMAT <- model_simMAT %>%
  mutate(exp_trial_num_item1 = (list-1)*tot_reps*t_per_list + (repetition-1)*t_per_list+trial_num_item1) %>%
  mutate(exp_trial_num_item2 = (list-1)*tot_reps*t_per_list + (repetition-1)*t_per_list+trial_num_item2)

#set up the event number per item1/item2:
model_simMAT <- model_simMAT %>%
  mutate(event_num_item1=ceiling(trial_num_item1/4),
         event_num_item2=ceiling(trial_num_item2/4))

enc_RT_to_add <- model_encRT_data %>%
  mutate(exp_trial_num_item1 = (list-1)*tot_reps*t_per_list + (repetition-1)*t_per_list+trials) %>%
  mutate(exp_trial_num_item2 = (list-1)*tot_reps*t_per_list + (repetition-1)*t_per_list+trials+1)


enc_RT_to_add <- enc_RT_to_add %>%
  select(-c(trials,repetition,list,pos_first_in_corr_pair,across_event,first_response_pleasantness,second_response_pleasantness))

enc_RT_to_add1 <- enc_RT_to_add %>%
  select(subject,exp_trial_num_item1,first_rawRT,first_RT_difFromRep1_posXrep1_minus_posXrepX,first_RT_difFromPos1Rep1_posXRep1MinRepX_min_pos1Rep1MinRepX,first_response_change)

enc_RT_to_add2 <- enc_RT_to_add %>%
  select(subject,exp_trial_num_item2,second_rawRT,second_RT_difFromRep1_posXrep1_minus_posXrepX,second_RT_difFromPos1Rep1_posXRep1MinRepX_min_pos1Rep1MinRepX,second_RT_diffpos1prev4,second_RT_diffpos1prev4_repXrep1,second_response_change)

model_simMAT <- merge(model_simMAT,enc_RT_to_add2,by=c("subject","exp_trial_num_item2"))

model_simMAT <- merge(model_simMAT,enc_RT_to_add1,by=c("subject","exp_trial_num_item1"))

model_simMAT <- model_simMAT[with(model_simMAT, order(subject,exp_trial_num_item1,exp_trial_num_item2)), ]
```
##### grab the full matrix similarity data
```{r analyse entire simMAT}

#set up:
subtract_Rep1 <- 1 #always 1 for this analysis

analysis_reg = "hipp" 

reg=1

model= 'filtered100s_mtc_clean_mc_wmcsf_3sphere'

#subtract tep1 or not
if (subtract_Rep1 == 1) {
allfiles <- list.files(path = paste(results_dir, "/results/encoding/rsa/regions_data", sep="/"), pattern = sprintf("%s*",analysis_reg), all.files = FALSE, full.names = TRUE, recursive = FALSE)

#set up the title
subRep1_ttl <- 'minus Rep1'

} else {
#this is without subtracting the first rep:
allfiles <- list.files(path = paste(results_dir, "regions_data_noRep1Subtraction", sep="/"), pattern = sprintf("%s*",analysis_reg), all.files = FALSE, full.names = TRUE, recursive = FALSE)

#set up the title
subRep1_ttl <- ''
}

#take only simMAT:
curr_file=allfiles[reg]

fname = basename(curr_file)

#get the roi:
roi=substr(fname,6,regexpr('_simMat', fname)-1) #get the roi name

#get the data
brain_data <- read.table(curr_file, header = TRUE,sep = "\t",dec = ".")
curr_data <- bind_cols(model_simMAT, brain_data)

#remove the first repetition, if the brain data is subtracted - because all brain values will be 0.
if (subtract_Rep1 == 1 ) {
  curr_data <- filter(curr_data,curr_data$repetition > 1)
}

#remove NA:
curr_data <- filter(curr_data, !is.na(curr_data$thirdTR))

#scale brain data within subject:
curr_data <- curr_data %>%
   mutate(scaled_brain_bysubj = scale_by(curr_data$thirdTR ~ subID))

#save a copy:
all_data <- curr_data #just to keep some copy of that, in case we mess up with things later on

print(sprintf("roi is %s, %s",roi,model))
```
##### prepare the data by events
```{r prepare the data by events}
fc_rep = 0
# has a bunch of things I set up for potential future control, but never ended 
#to examine how CA23 similarity (within vs. across events) is related to boundary RT. The boundary is between two events. We thus averaged, per event, the similarity within the event, and the similarity within the next event. We also average the similarity between each two nearing events (that's the main analysis)

curr_data <- all_data

#take only relevant items:
curr_analysis_data_all <- curr_data %>%
  filter(fac_wa_control_time != 0)

#average - I have one RT measure, I'd want to have a difference measure in the brain - within vs. across: Note that I need to average RTs separately, bc otherwise I'm taking items twice.
curr_analysis_data_within1 <- data_frame(curr_analysis_data_all %>%
                      filter(fac_wa_control_time == 2) %>%                   
  group_by(subID,list,repetition,event_num_item1) %>%
  summarize(mean_sim_within_curr = mean(thirdTR, na.rm = TRUE)))

curr_analysis_data_within2 <- data_frame(curr_analysis_data_all %>%
                      filter(fac_wa_control_time == 2) %>%                   
  group_by(subID,list,repetition,event_num_item1) %>%
  summarize(mean_sim_within_next = mean(thirdTR, na.rm = TRUE)))

#now to match the events - need to subtract 1, and add Nan for event6 (I checkted that it's good):
curr_analysis_data_within2$event_num_item1 <- curr_analysis_data_within2$event_num_item1 -1
#data_within2 will be matched with data_within1 based on event_num. The first event is not the following event of any event. It will be changed to 0 in the command above. That will then be changed to 6 (to match with the 6th event), just as a place holder, to then place NA for the 6th event. So, when we match this data with within1, the similarity of the next event for the 6th events will be NA, becasue there's no next event.
curr_analysis_data_within2 <- curr_analysis_data_within2 %>%
mutate(event_num_item1 = if_else(event_num_item1 == 0,6,event_num_item1),
       mean_sim_within_next = if_else(event_num_item1 == 6, NaN,mean_sim_within_next))

#in simMAT the similarity values are to the future - so if event_num_item1 and fac_wa_control_time == 1, it's across with the next event
curr_analysis_data_across <- data_frame(curr_analysis_data_all %>%
                      filter(fac_wa_control_time == 1) %>%                   
  group_by(subID,list,repetition,event_num_item1) %>%
  summarize(mean_sim_across = mean(thirdTR, na.rm = TRUE)))

#I just wanted to add a bunch of NA for the "6" event across (bc there's no across event 6), so I used the data_within2 data frame
temp_data <- as.data.frame(filter(curr_analysis_data_within2,curr_analysis_data_within2$event_num_item1 == 6))
temp_data <- temp_data %>%
  mutate(mean_sim_across = mean_sim_within_next)%>% #just grab NA vals for the last event - not really changing within to across
  select(-mean_sim_within_next)

curr_analysis_data_across <- bind_rows(curr_analysis_data_across,temp_data)

#merge it all:
curr_within <- merge(curr_analysis_data_within1,curr_analysis_data_within2,by=c("subID","list","repetition","event_num_item1")) %>%
  mutate(mean_sim_within = (mean_sim_within_curr + mean_sim_within_next)/2)

curr_analysis_data <- merge(curr_within,curr_analysis_data_across,by=c("subID","list","repetition","event_num_item1"))%>%
  mutate(mean_sim_diff_curr_ac_next = mean_sim_within_curr - mean_sim_across,
         mean_sim_diff_next_ac_prev = mean_sim_within_next - mean_sim_across,
         mean_sim_diff = mean_sim_within - mean_sim_across)

#### now deal with encoding RTs: ####

#measures we have from MATLAB:
model_encRT_data$subID <- factor(model_encRT_data$subject)
#set up the event number:
model_encRT_data <- model_encRT_data %>%
  mutate(event_num_item1=ceiling(trials/4))

#this is so that the event number of boundary4to1/learning_boundary4to1 would be that of pos4, aligned with similarity across/pos4_1
eventRTs <- data_frame(model_encRT_data %>%
  filter (model_encRT_data$repetition != 1 ) %>%
  group_by(subID,list,repetition,event_num_item1) %>% #there is only one item, I call it event_num_item1 to match with curr_analysis_data
  summarize(boundary4to1 = mean(second_RT_diffpos1prev4, na.rm = TRUE)))

curr_analysis_data <- merge(curr_analysis_data,eventRTs,by=c("subID","list","repetition","event_num_item1")) 


# for the rest, since I'm taking the second_RT (becaue that has the 24th item, doesn't have the first item per list, which is anyway excluded for being high just bc it's the first...), need to shift trials, and recalculate the event numbers - to make sure that they are correct:
#calculate each pos, in each rep:
pos_RT <- model_encRT_data %>%
  filter(model_encRT_data$repetition != 1 )
#I'm going to take the second_rawRT - so change the numbers in pos_first_in_corr_pair
pos_RT <- pos_RT %>%
  mutate(pos_first_in_corr_pair = pos_first_in_corr_pair + 1,
         trials = trials + 1)
pos_RT <- pos_RT %>%
  mutate(pos_first_in_corr_pair = if_else(pos_first_in_corr_pair == 5,1,pos_first_in_corr_pair),
         event_num_item1=ceiling(trials/4))


eventRTs2 <- pos_RT %>%
  group_by(subID,list,repetition,event_num_item1) %>%
  summarize(learn_all = mean(second_RT_difFromRep1_posXrep1_minus_posXrepX, na.rm = TRUE),
    event_learn = mean(second_RT_difFromPos1Rep1_posXRep1MinRepX_min_pos1Rep1MinRepX, na.rm = TRUE))


curr_analysis_data <- merge(curr_analysis_data,eventRTs2,by=c("subID","list","repetition","event_num_item1")) 

#calculate each pos, in each rep:
all_pos_RT <- pos_RT %>%
               select(c(subID,list,repetition,pos_first_in_corr_pair,event_num_item1,second_rawRT,second_RT_difFromRep1_posXrep1_minus_posXrepX)) %>%
  mutate(rawRT = second_rawRT,
        learn=second_RT_difFromRep1_posXrep1_minus_posXrepX) %>%
  select(-c(second_rawRT,second_RT_difFromRep1_posXrep1_minus_posXrepX))

all_pos_RT <- all_pos_RT %>% pivot_wider(names_from = pos_first_in_corr_pair, values_from = c("rawRT","learn"), names_sep="")

#merge it with brain data (before we change all_pos_RT to do the next_event_RTs):
curr_analysis_data <- merge(curr_analysis_data,all_pos_RT,by=c("subID","list","repetition","event_num_item1")) 


if (fc_rep == 1) {
 curr_analysis_data$fac_rep <- factor(curr_analysis_data$repetition)
} else {
   curr_analysis_data$fac_rep <- curr_analysis_data$repetition
}

#factor list:
curr_analysis_data$fac_list <- factor(curr_analysis_data$list)
#fact event num:
curr_analysis_data$fac_event_num <- factor(curr_analysis_data$event_num_item1)

#save it all
event_data <- curr_analysis_data
```
##### run models - sim with encoding RT
```{r run list level models}

run_glmer <- 0

#set up for graphs:
all_spectral<-brewer.pal(11,"RdYlBu")
myspec_within <-all_spectral[c(2,3,4)]

myspec <-c(myspec_within[2]) #,myspec_across[2]

reps=c(5)

labels_rep <- c(
  "1" = "Rep1",
  "2" = "Rep2",
  "3" = "Rep3",
  "4" = "Rep4",
  "5" = "Rep5"
)

behav_varname <- c('boundary4to1','rawRT1','rawRT4')

contrasts_diff <- c('mean_sim_within_curr','mean_sim_within_next','mean_sim_across','mean_sim_within','mean_sim_diff')

print("######## RUN LMER MODELS #######")
for (bb in behav_varname[c(1)]) {
  for (cc in contrasts_diff[c(5)]) {
    
    #load data and filter out NaN
    curr_analysis_data <- event_data
    curr_analysis_data <- filter(curr_analysis_data,!is.na(curr_analysis_data[[cc]]))
    curr_analysis_data <- filter(curr_analysis_data,!is.na(curr_analysis_data[[bb]]))
    
    #reported for stats:
    # curr_analysis_data <- curr_analysis_data %>%
    #    mutate(scaled_RT = curr_analysis_data[[bb]]) %>%
    #    mutate(scaled_brain_bysubj_temp = scale_by(curr_analysis_data[[cc]] ~ subID)) 
    # 
    
    #attempt for ggeffect
    curr_analysis_data <- curr_analysis_data %>%
       mutate(scaled_RT = curr_analysis_data[[bb]]) %>%
       mutate(scaled_brain_bysubj = curr_analysis_data[[cc]]) 
    
    curr_analysis_data <- curr_analysis_data %>%
      group_by(subID) %>%
      mutate(across(scaled_brain_bysubj,scale)) %>%
      ungroup()
    
    #if want to report standardized beta, standardize also RTs:
    # curr_analysis_data <- curr_analysis_data %>%
    #    mutate(scaled_RT = scale(curr_analysis_data[[bb]], center = FALSE)) %>%
    #    mutate(scaled_brain_bysubj = scale_by(curr_analysis_data[[cc]] ~ subID))

    
    print(sprintf("########### roi: %s, brain: %s, behavior: %s ############",roi,cc,bb))
  
    
    print('###### ANALYSIS PER REPETITION #######')
    for ( r in reps) {
    
    curr_rep_data <- filter(curr_analysis_data,curr_analysis_data$repetition == r)
    
    #null mdl
    null_mdl=lmer(scaled_RT ~ fac_list +  fac_event_num + (1|subID),data = curr_rep_data, REML = FALSE)
    
    #### scaled brain main effect model:
    print(sprintf("REP %d: %s, scaled BRAIN %s, behavior: %s, %s",r,roi,cc,bb, subRep1_ttl))
    brain_mdl=lmer(scaled_RT ~ scaled_brain_bysubj + fac_list + fac_event_num + (1|subID),data = curr_rep_data, REML = FALSE)
    print(summary(brain_mdl))
    
    
    print(anova(null_mdl,brain_mdl))
    AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(brain_mdl)[2])
    print(sprintf("AIC diff: %.2f",AIC_diff))
    print("")
    
    curr_p <- ggplot(curr_rep_data, aes(x=scaled_brain_bysubj, y=scaled_RT)) +
           geom_point(shape=19, colour = "grey", size = 1, alpha = .6) +
           geom_smooth(method=lm,color = myspec[1],fill = myspec[1]) + 
           labs(x = sprintf("%s (RepX minus Rep1)",cc), y = bb, title = roi) +
           theme_bw() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
           
    print(curr_p)
    
    
    #get clean effect - sum score:
    ggef_data <- ggeffect(brain_mdl,terms ="scaled_brain_bysubj",ci.lvl = 0.95,type = "fe")
    
    
    #that does the ploting:
    p_ggef <- ggplot(ggef_data,aes(x = x, y = predicted)) +
          geom_ribbon(aes(ymin = conf.low,
                          ymax = conf.high),
                          fill = myspec[1],alpha=.4) + 
          stat_smooth(method = "lm", se = TRUE, color = myspec[1]) +
          labs(x = sprintf("%s (RepX minus Rep1)",cc), y = bb) +
          theme_classic() +
          theme(aspect.ratio=1,
                axis.text=element_text(size=12),
                axis.title=element_text(size=16))

      
    }
    
  }

} #end the behavior con



```
## CA3 control for color
```{r color models}
reps=c(5)
flt_gap <- 0 #take out gap > 19, because these exist only for across color
run_all_reps <- 0
#reported in the paper: all gaps, excluding within/adjacent events (see below).
#Other things here are sanity checks etc.
######## color models #######
#obe question is whether an event only codes for color, or is there something with the event iteself?
#when I control for time, I by definition cannot control for color as well. However, I can see wether"
#1) there is an effect of color at all.
#2) if the event model works (w/o controling for time), is the event model significant also when controling for color

######
if (flt_gap == 0) {
curr_data <- all_data
flt_gap_ttl <- "all gaps"
} else {
curr_data <- filter(all_data,all_data$gap <= 19)
flt_gap_ttl <- "gaps <= 19"
}

if (run_all_reps == 1) {
null_mdl=lmer(thirdTR ~ fac_list + (1|subID),curr_data,REML=F)
color_mdl=lmer(thirdTR ~ color_model + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("color model, roi: %s, %s",roi,flt_gap_ttl))
print(anova(null_mdl,color_mdl))
print("")

#color model control gap:
gap_mdl=lmer(thirdTR ~ gap + fac_list + (1|subID),curr_data,REML=F)
color_and_gap_mdl=lmer(thirdTR ~ color_model + gap + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("color model, controlling for gap roi: %s, %s",roi,flt_gap_ttl))
print(anova(color_and_gap_mdl,gap_mdl))
print("")

#color by gap
color_and_gap_mdl=lmer(thirdTR ~ color_model + gap + fac_list + (1|subID),curr_data,REML=F)
color_by_gap_mdl=lmer(thirdTR ~ color_model * gap + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("color by gap, roi: %s, %s",roi,flt_gap_ttl))
print(anova(color_and_gap_mdl,color_by_gap_mdl))
print("")

#color by gap - controlling for event:
color_and_gap_mdl=lmer(thirdTR ~ color_model + gap + fac_event_mdl + fac_list + (1|subID),curr_data,REML=F)
color_by_gap_mdl=lmer(thirdTR ~ color_model * gap + fac_event_mdl + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("color by gap control gap, roi: %s, %s",roi,flt_gap_ttl))
print(anova(color_and_gap_mdl,color_by_gap_mdl))
print("")


#Is there an additional effect of event, controlling for color - I cannot do that with the event controling for time, bc there is no color that is not also within-event, so that's using the event model
event_and_color_mdl = lmer(thirdTR ~ fac_event_mdl + color_model + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("event and color model over color,roi: %s, %s",roi,flt_gap_ttl))
print(anova(event_and_color_mdl,color_mdl))
print("")

color_and_gap_mdl=lmer(thirdTR ~ color_model + gap + fac_list + (1|subID),curr_data,REML=F)
event_and_color_and_gap_mdl = lmer(thirdTR ~ fac_event_mdl + color_model + gap + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("event and color model over color (control gap),roi: %s, %s",roi,flt_gap_ttl))
print(anova(event_and_color_and_gap_mdl,color_and_gap_mdl))
print("")

#is there an effect of color controling for within/across? I.e., making sure that I don't see a color effect bc within are higher, and also the same color:
event_mdl = lmer(thirdTR ~ fac_event_mdl + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("event and color model over event,roi: %s, %s",roi,flt_gap_ttl))
print(anova(event_and_color_mdl,event_mdl))
print("")


#color, controlling for both gap and event:
event_gap_mdl = lmer(thirdTR ~ fac_event_mdl + gap + fac_list + (1|subID),curr_data,REML=F)
color_event_gap_mdl = lmer(thirdTR ~ color_model + fac_event_mdl + gap + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("color model, controling for both event and gap in the model, roi: %s, %s",roi,flt_gap_ttl))
print(anova(event_gap_mdl,color_event_gap_mdl))
print("")

#actually exclude the data
data_ex_within_prev_event <- filter(curr_data,curr_data$gap > 4)
null_mdl=lmer(thirdTR ~ gap + fac_list + (1|subID),data_ex_within_prev_event ,REML=F)
color_mdl=lmer(thirdTR ~ color_model + fac_list + gap + (1|subID),data_ex_within_prev_event ,REML=F)
print(sprintf("color model, EXCLUDE WITHIN/PREV EVENT, and controling for gap, roi: %s, %s",roi,flt_gap_ttl))
print(anova(null_mdl,color_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(color_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#color by rep:
color_and_rep_mdl=lmer(thirdTR ~ color_model + repetition + fac_list + (1|subID),curr_data,REML=F)
color_by_rep_mdl=lmer(thirdTR ~ color_model * repetition + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("color model by rep, roi: %s, %s",roi,flt_gap_ttl))
print(anova(color_and_rep_mdl,color_by_rep_mdl))
print("")

#color by gap by rep:
color_by_gap_and_rep_mdl=lmer(thirdTR ~ color_model*gap + color_model*repetition + gap*repetition + fac_list + (1|subID),curr_data,REML=F)
color_by_gap_by_rep_mdl=lmer(thirdTR ~ color_model*gap*repetition + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("color model by rep, roi: %s, %s",roi,flt_gap_ttl))
print(anova(color_by_gap_by_rep_mdl,color_by_gap_and_rep_mdl))
print("")

#color by rep, controling for event and gap:
color_and_rep_mdl=lmer(thirdTR ~ color_model + repetition + fac_event_mdl + gap + fac_list + (1|subID),curr_data,REML=F)
color_by_rep_mdl=lmer(thirdTR ~ color_model * repetition + fac_event_mdl + gap + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("color model by rep, controling for event and gap, roi: %s, %s",roi,flt_gap_ttl))
print(anova(color_and_rep_mdl,color_by_rep_mdl))
print("")

#color by rep, excluding within/prev and controling gap:
color_and_rep_mdl=lmer(thirdTR ~ color_model + repetition + gap + fac_list + (1|subID),data_ex_within_prev_event,REML=F)
color_by_rep_mdl=lmer(thirdTR ~ color_model * repetition + gap + fac_list + (1|subID),data_ex_within_prev_event,REML=F)
print(sprintf("color model by rep, EXCLUDE WITHIN/PREV EVENT, controling for event and gap, roi: %s, %s",roi,flt_gap_ttl))
print(anova(color_and_rep_mdl,color_by_rep_mdl))
print("")

} #ends the run all reps conditional

#create the ggpred object, we'll plot it later:
#position code interaction with the position identity and rep, exclude rep1 to avoid erroneous gap estimation
data_ex_within_prev_event <- filter(curr_data,curr_data$gap > 4)
if (subtract_Rep1 == 1) {
temp_data <- filter(data_ex_within_prev_event,data_ex_within_prev_event$repetition > 1)
} else {
  temp_data <- data_ex_within_prev_event
}

color_by_rep_mdl=lmer(thirdTR ~ color_model*fac_rep + gap + fac_list + (1|subID),temp_data,REML=F)

GGPred_by_rep_clear_gap <- ggpredict(color_by_rep_mdl, terms = c("color_model","fac_rep")) 
#I like to plot SE of the mean rather than conf interval, so calculate that:
GGPred_by_rep_clear_gap$SE.low <- GGPred_by_rep_clear_gap$predicted-GGPred_by_rep_clear_gap$std.error
GGPred_by_rep_clear_gap$SE.high <- GGPred_by_rep_clear_gap$predicted+GGPred_by_rep_clear_gap$std.error
#change names:
names(GGPred_by_rep_clear_gap)[names(GGPred_by_rep_clear_gap) == "group"] <- "repetition"
names(GGPred_by_rep_clear_gap)[names(GGPred_by_rep_clear_gap) == "x"] <- "color_model"
names(GGPred_by_rep_clear_gap)[names(GGPred_by_rep_clear_gap) == "predicted"] <- "mean_sim"

GGPred_by_rep_clear_gap$fac_color_mdl <- factor(GGPred_by_rep_clear_gap$color_model)

#### PER EACH REP:

for ( r in reps) {
print(sprintf("################# rep %d ####################",r))
curr_rep_data <- filter(curr_data,curr_data$repetition == r)

null_mdl=lmer(thirdTR ~ fac_list + (1|subID),curr_rep_data,REML=F)
color_mdl=lmer(thirdTR ~ color_model + fac_list + (1|subID),curr_rep_data,REML=F)
print(sprintf("REP %d: color model, roi: %s, %s",r,roi,flt_gap_ttl))
print(anova(null_mdl,color_mdl))
print("")

#color model control gap:
gap_mdl=lmer(thirdTR ~ gap + fac_list + (1|subID),curr_rep_data ,REML=F)
color_and_gap_mdl=lmer(thirdTR ~ color_model + gap + fac_list + (1|subID),curr_rep_data ,REML=F)
print(summary(color_and_gap_mdl))
print(sprintf("REP %d: color model, controlling for gap roi: %s, %s",r,roi,flt_gap_ttl))
print(anova(color_and_gap_mdl,gap_mdl))
print("")

#event over color:
event_and_color_mdl = lmer(thirdTR ~ fac_event_mdl + color_model + fac_list + (1|subID),curr_rep_data,REML=F)
print(sprintf("REP %d: event and color model over color, roi: %s, %s",r,roi,flt_gap_ttl))
print(anova(event_and_color_mdl,color_mdl))
print("")

#event and color, control gap
event_and_color_and_gap_mdl = lmer(thirdTR ~ fac_event_mdl + color_model + gap + fac_list + (1|subID),curr_rep_data,REML=F)
print(sprintf("REP %d: event and color model over color (control gap), roi: %s, %s",r,roi,flt_gap_ttl))
print(anova(event_and_color_and_gap_mdl,color_and_gap_mdl))
print("")

#actually exclude the data: THIS IS REPORTED IN THE PAPER
curr_rep_data_ex_within_prev_event <- filter(curr_rep_data,curr_rep_data$gap > 4)
null_mdl=lmer(thirdTR ~ gap + fac_list + (1|subID),curr_rep_data_ex_within_prev_event ,REML=F)
color_mdl=lmer(thirdTR ~ color_model + fac_list + gap + (1|subID),curr_rep_data_ex_within_prev_event ,REML=F)
print(sprintf("REP %d: color model, EXCLUDE WITHIN/PREV EVENT, and controling for gap, roi: %s, %s",r,roi,flt_gap_ttl))
print(anova(null_mdl,color_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(color_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


print(sprintf("COLOR MODEL t-test %s", roi))
curr_data_average <- curr_rep_data_ex_within_prev_event %>%
  group_by(subID,color_model) %>%
  summarize(curr_brain = mean(thirdTR, na.rm = TRUE))


res_t <- t.test(curr_brain ~ color_model, data = curr_data_average, paired = TRUE)
print(res_t)



#diff_optims <- allFit(color_mdl, maxfun = 1e5)
#new_full_mdl <- reach_convergence(color_mdl)




#color, controlling for both gap and event:
event_gap_mdl = lmer(thirdTR ~ fac_event_mdl + gap + fac_list + (1|subID),curr_rep_data,REML=F)
color_event_gap_mdl = lmer(thirdTR ~ color_model + fac_event_mdl + gap + fac_list + (1|subID),curr_rep_data,REML=F)
print(sprintf("REP %d: color model, controling for both event and gap in the model, roi: %s, %s",r,roi,flt_gap_ttl))
print(anova(event_gap_mdl,color_event_gap_mdl))
AIC_diff <- (extractAIC(event_gap_mdl)[2] - extractAIC(color_event_gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


##### had convergence issues, so lm, exclude within/previous items:
sum_curr_rep_data <- curr_rep_data_ex_within_prev_event %>%
group_by(subID, color_model, fac_list ) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE))

null_mdl=lm(mean_sim ~ fac_list, sum_curr_rep_data)
color_mdl=lm(mean_sim ~ color_model + fac_list, sum_curr_rep_data)
print(sprintf("REP %d: ***LM***: EXCLUDE WITHIN/PREV EVENT, color mdl, roi: %s, %s",r,roi,flt_gap_ttl))
#print(summary(color_mdl))
print(anova(color_mdl,null_mdl))

}

```

####  plot color models
```{r plot color models}
flt_gap <- 0 #take out gap > 19, because these exist only for across color

if (flt_gap == 0) {
curr_data <- all_data
flt_gap_ttl <- "all gaps"
} else {
curr_data <- filter(all_data,all_data$gap <= 19)
flt_gap_ttl <- "gaps < 19"
}
################ plot things ##############
#get the summary days
summary_color_position_rep <- curr_data %>%
  group_by(subID, fac_color_mdl, fac_event_pos_item1, repetition ) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE))

summary_color_wa_rep <- curr_data %>%
  group_by(subID, fac_color_mdl, fac_event_mdl, repetition ) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE))

summary_color_rep <- curr_data %>%
  group_by(subID, fac_color_mdl, repetition ) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE))

summary_color_gap_rep <- curr_data %>%
  group_by(subID, fac_color_mdl, repetition,gap ) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE))

# excluding items within/prev event:
summary_color_rep_ex_wprev_event <- data_ex_within_prev_event %>%
  group_by(subID, fac_color_mdl, repetition ) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE))


summary_color_rep_ac_sub <- data_ex_within_prev_event %>%
  group_by(fac_color_mdl, repetition ) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE))


########### actually plot things ###########
all_spectral<-brewer.pal(11,"RdYlBu")
myspec_within <-all_spectral[c(2,3,4,5)]

#plot event by gap by rep
labels_rep <- c(
  "1" = "Rep1",
  "2" = "Rep2",
  "3" = "Rep3",
  "4" = "Rep4",
  "5" = "Rep5"
)

p_collapse_pos <- ggplot(summary_color_rep, aes(x = repetition, y = mean_sim,color = fac_color_mdl)) + 
  geom_hline(yintercept=0, colour="black", linetype = "dotted") +
  stat_summary(data = summary_color_rep, fun.data = mean_se_, geom = "pointrange",aes(color = fac_color_mdl), position_dodge(width = .9),size=1) +
  labs(x = 'Repetition', y = 'similarity (thirdTR)', title = roi) +
  scale_color_manual(values = c("grey","black"),
                       name=NULL,
                       breaks=c("1", "0"),
                       labels=c("same-color","other-color")) +
  theme_gap

p_collapse_pos_ex_wprev_event <- ggplot(summary_color_rep_ex_wprev_event, aes(x = repetition, y = mean_sim,color = fac_color_mdl)) + 
  geom_hline(yintercept=0, colour="black", linetype = "dotted") +
  stat_summary(data = summary_color_rep_ex_wprev_event, fun.data = mean_se_, geom = "pointrange",aes(color = fac_color_mdl), position_dodge(width = .9),size=1) +
  labs(x = 'Repetition', y = 'similarity (thirdTR), ex_within/prev', title = roi) +
  scale_color_manual(values = c("grey","black"),
                       name=NULL,
                       breaks=c("1", "0"),
                       labels=c("same-color","other-color")) +
  theme_gap

#plot clearing the gap effect, using the GGeffect data.frame we created above
p_collapse_pos_ex_w_prev_clean_gap <- ggplot(GGPred_by_rep_clear_gap,aes(x = repetition, y = mean_sim,color = fac_color_mdl)) + 
  geom_hline(yintercept=0, colour="black", linetype = "dotted") +
  geom_pointrange(aes(ymin = SE.low, ymax = SE.high), position = position_dodge(width = .9),size = 1) +
  labs(x = 'Repetition', y = 'similarity (thirdTR), ex_within/prev', title = roi) +
  scale_color_manual(values = c("grey","black"),
                       name=NULL,
                       breaks=c("1", "0"),
                       labels=c("same-color","other-color")) +
  theme_gap                            

#stat_summary(data = summary_color_gap_rep, fun.data = mean_se_, geom = "pointrange",aes(color = fac_color_mdl), position_dodge(width = .9),size=1) +

### event model ####
p_em_rep <- ggplot(summary_color_wa_rep, aes(x = fac_event_mdl, y = mean_sim,color = fac_color_mdl)) + 
  geom_hline(yintercept=0, colour="black", linetype = "dotted") +
  stat_summary(data = summary_color_wa_rep, fun.data = mean_se_, geom = "pointrange",aes(color = fac_color_mdl), position_dodge(width = .9),size=1) +
  scale_color_manual(values = c("grey","black"),
                       name=NULL,
                       breaks=c("1", "0"),
                       labels=c("same-color","other-color")) +
  facet_wrap(~repetition,labeller = labeller(repetition = labels_rep)) + 
  theme_all_gaps
###### plot by gap ######  
p_gap_rep <- ggplot(summary_color_gap_rep, aes(x = gap, y = mean_sim,color = fac_color_mdl)) + 
  geom_hline(yintercept=0, colour="black", linetype = "dotted") +
  stat_summary(data = summary_color_gap_rep, fun.data = mean_se_, geom = "pointrange",aes(color = fac_color_mdl), position_dodge(width = .9),size=1) +
  scale_color_manual(values = c("grey","black"),
                       name=NULL,
                       breaks=c("1", "0"),
                       labels=c("same-color","other-color")) +
  facet_wrap(~repetition,labeller = labeller(repetition = labels_rep)) + 
  theme_all_gaps

p_gap_rep <- ggplot(summary_color_gap_rep, aes(x = gap, y = mean_sim,color = fac_color_mdl)) + 
  geom_hline(yintercept=0, colour="black", linetype = "dotted") +
  geom_smooth() +
  scale_color_manual(values = c("grey","black"),
                       name=NULL,
                       breaks=c("1", "0"),
                       labels=c("same-color","other-color")) +
  facet_wrap(~repetition,labeller = labeller(repetition = labels_rep)) + 
  theme_all_gaps

#grid.arrange(p_collapse_pos,p_collapse_pos_ex_wprev_event, nrow=1)

```

# FOR JNEURO REVISION:
## DG control for other n+1 positions in other events (of the same color or not)
```{r DG control for other n+1 positions in other events}
# this would be the parallel to  show that n-same position and color as n+1, but from other events, is not lower than n-same position and color as n+2 and n+3, but from other events, - that I don't get this effect. so do the same analyses exactly, but taking out the within/adjacent events
# *analysis 2 is a similar logic to what we report for CA3 - showing that a color model doesn't work - here I see that, and I also got the interaction.
reps=c(5)

for ( r in reps) {
print(sprintf("################# rep %d ####################",r))
curr_rep_data <- filter(all_data,all_data$repetition == r)

#### analysis 2: this will run the within-event analyses above, but computing on items from other events of the same color:

#only WITHIN - all gaps
curr_rep_same_color_other_events_data <- filter(curr_rep_data , ((curr_rep_data$wa_control_time  == 0) & (curr_rep_data$color_model  == 1)))#not within or across adjacent, and same colpor

#but - that includes also items in the same position - remove:
curr_rep_same_color_other_events_data <- filter(curr_rep_same_color_other_events_data,curr_rep_same_color_other_events_data$gap != 8)
curr_rep_same_color_other_events_data <- filter(curr_rep_same_color_other_events_data,curr_rep_same_color_other_events_data$gap != 16)

#re-calc the gap:
curr_rep_same_color_other_events_data <- curr_rep_same_color_other_events_data %>%
  mutate(pos_gap = abs(event_pos_item1 - event_pos_item2))

null_mdl=lmer(thirdTR ~ gap + fac_list + (1|subID),curr_rep_same_color_other_events_data,REML=F)
gap_mdl=lmer(thirdTR ~ pos_gap + gap+ fac_list + (1|subID),curr_rep_same_color_other_events_data,REML=F)
print(sprintf("same color, other events, main effect of gap, rep %d, %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

summary_same_color_other_events_rep5 <- data_frame(curr_rep_same_color_other_events_data %>%
  group_by(subID, pos_gap) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE)))

mean_pos_gap_rep5 <- data_frame(summary_same_color_other_events_rep5  %>%
  group_by(pos_gap) %>%
  summarize(mean_sim = mean(mean_sim, na.rm = TRUE)))


## WITHIN AND ACROSS EVENTS TOGETHER
#take only same color:
curr_rep_same_color_other_events_data <- filter(curr_rep_data, curr_rep_data$color_model  == 1)#only same colpor

#but - that includes also items in the same position - remove:
curr_rep_same_color_other_events_data <- filter(curr_rep_same_color_other_events_data,curr_rep_same_color_other_events_data$gap != 8)
curr_rep_same_color_other_events_data <- filter(curr_rep_same_color_other_events_data,curr_rep_same_color_other_events_data$gap != 16)

#re-calc the gap:
curr_rep_same_color_other_events_data <- curr_rep_same_color_other_events_data %>%
  mutate(pos_gap = abs(event_pos_item1 - event_pos_item2))


#only event :
null_mdl=lmer(thirdTR ~ gap + fac_list + (1|subID),curr_rep_same_color_other_events_data,REML=F)

full_mdl=lmer(thirdTR ~ fac_wa_control_time + gap + fac_list + (1|subID),curr_rep_same_color_other_events_data,REML=F)
print(sprintf("only event - which is like temporal gap, rep %d, %s",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#gap and event interaction:
null_mdl=lmer(thirdTR ~ fac_wa_control_time + pos_gap + gap + fac_list + (1|subID),curr_rep_same_color_other_events_data,REML=F)

full_mdl=lmer(thirdTR ~ fac_wa_control_time * pos_gap + gap+ fac_list + (1|subID),curr_rep_same_color_other_events_data,REML=F)
print(sprintf("same color, other events, gap by event, rep %d, %s",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#only WITHIN - all gaps
# THIS IS IDENTICAL TO PRIAMRY ANALYSIS
curr_rep_onlyWithOrAc_data <- filter(curr_rep_same_color_other_events_data , curr_rep_same_color_other_events_data$wa_control_time  == 2)

null_mdl=lmer(thirdTR  ~ fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
gap_mdl=lmer(thirdTR  ~ pos_gap + fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
print(sprintf("only WITHIN, main effect of pos gap, rep %d, %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


#only ACROSS - all gaps
curr_rep_onlyWithOrAc_data <- filter(curr_rep_same_color_other_events_data , curr_rep_same_color_other_events_data$wa_control_time  == 0)

null_mdl=lmer(thirdTR  ~ fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
gap_mdl=lmer(thirdTR  ~ pos_gap + fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
print(sprintf("only ACROSS, main effect of pos gap, rep %d, %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

summary_same_color_events_rep5 <- data_frame(curr_rep_same_color_other_events_data %>%
  group_by(subID, fac_wa_control_time, pos_gap) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE)))

mean_color_pos_gap_rep5 <- data_frame(summary_same_color_events_rep5  %>%
  group_by(fac_wa_control_time, pos_gap) %>%
  summarize(mean_sim = mean(mean_sim, na.rm = TRUE)))
}

########### actually plot things ###########
all_spectral<-brewer.pal(11,"RdYlBu")
myspec_within <-all_spectral[c(2,3,4)]
#myspec_across <-all_spectral[c(10,9,8)] #blues
all_spectral<-brewer.pal(9,"Greys")
myspec_across <-all_spectral[c(4,5,6)] #greys
myspec <-c(myspec_across[2],myspec_within[2])

#plot event by gap by rep - don't plot rep1
labels_rep <- c(
  "1" = "Repetition 1",
  "2" = "Repetition 2",
  "3" = "Repetition 3",
  "4" = "Repetition 4",
  "5" = "Repetition 5"
)

labels_gap <- c(
  "1" = "Gap1",
  "2" = "Gap2",
  "3" = "Gap3"
)

labels_wa <- c(
  "1" = "across",
  "2" = "within"
)


#coord_cartesian(ylim = c(-.018,.023)) +
#this fig is for the main figures:
rep5 <- ggplot(summary_gap_rep5, aes(x = gap, y = mean_sim)) +
  stat_summary(data = summary_gap_rep5, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
  labs(x = 'Gap', y = 'Similarity (Rep5 minus Rep1)') +
  scale_color_manual(values = myspec) +
  #scale_x_continuous(breaks = c(1,2,3),labels=c(0,1,2)) +
  theme_gap + theme(legend.position = "none") 

print(rep5)

#analysis 2:
p_same_color_other_events_rep5 <- ggplot(summary_same_color_other_events_rep5, aes(x = pos_gap, y = mean_sim)) +
  stat_summary(data = summary_same_color_other_events_rep5, fun.data = mean_se_, geom = "pointrange",aes(x = pos_gap), position_dodge(width = .9),size=1) +
  labs(x = 'Position gap', y = 'Similarity (Rep5 minus Rep1)') +
  scale_color_manual(values = myspec[2]) +
  #scale_x_continuous(breaks = c(1,2,3),labels=c(0,1,2)) +
  theme_gap + theme(legend.position = "none") 

p_same_color_events_rep5 <- ggplot(summary_same_color_events_rep5, aes(x = pos_gap, y = mean_sim,color = fac_wa_control_time)) +
  stat_summary(data = summary_same_color_events_rep5, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
  labs(x = 'Position gap', y = 'Similarity (Rep5 minus Rep1)') +
  scale_color_manual(values = myspec_within[c(3,2)]) +
  #scale_x_continuous(breaks = c(1,2,3),labels=c(0,1,2)) +
  theme_gap + theme(legend.position = "none") 

```
## DG similarity with temporal TEST RT
### Brain cue-target sim to predict RTs at memory test
```{r n+1 and RTs at memory test}
#only analyze rep 5:
r <- 5
curr_rep_data <- filter(all_data,all_data$repetition == r)

#take only gap of 1:
curr_rep_data <- filter(curr_rep_data , (curr_rep_data$gap  == 1))

print(sprintf("########### roi: %s ############",roi))

model_TempTestRT_data <- model_TempTestRT_data %>%
  mutate(trial_num_item1 = trials)
#brain_data <- read.table(curr_file, header = TRUE,sep = "\t",dec = ".")
curr_data <- merge(curr_rep_data,model_TempTestRT_data, by=c("subject","list","trial_num_item1"))
#take only hc
curr_data <- filter(curr_data, curr_data$hc == 1)
curr_data <- curr_data %>%
  mutate(fac_pos = factor(pos_first_in_corr_pair)) %>%
  mutate(fac_list = factor(curr_data$list)) %>%
  mutate(subID = factor(curr_data$subject)) %>%
  mutate(scaled_RT_pooled = scale(curr_data$temporalTestRT, center = FALSE)) %>% #this is like the behavioral analysis alone
  mutate(scaled_RT_bysubj = scale_by(curr_data$temporalTestRT ~ subject)) %>%
  mutate(sc_TrialOrderAll = scale(curr_data$temporalTestOrderAllTrials))


curr_data <- filter(curr_data,!(is.na(curr_data$scaled_brain_bysubj)))

#### models:
#re-estimate RT data:
#I excluded similarity values that are more than +-3SD. That means that some values might be NaN in the brain data. To be able to compare it to the RT model, models need to be estimated on the same data. So I estimate the RT model again, depends on the data I use. also, all models need to be estimated to the same data.. so I need to exclude rows based on the NaNs in the brain


#position and order model - this is the best model, see above.. this becomes now our null model
null_mdl=glmer(scaled_RT_pooled ~ fac_pos + sc_TrialOrderAll + fac_list + (1|subID),data = curr_data, family = inverse.gaussian(link = 'identity'))
#this converge with default setting, or with control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)

#now that this is the model for RTs, the models including the brain will be tested against this model, previous versions are commented out, below:

#### scaled brain main effect model:
print(sprintf("%s, scaled BRAIN, main effect, Rep%d, %s",roi,r,subRep1_ttl))
brain_mdl=glmer(scaled_RT_pooled ~ scaled_brain_bysubj + fac_pos + sc_TrialOrderAll + fac_list +  (1|subID),data = curr_data, family = inverse.gaussian(link = 'identity')) #control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))

print(anova(null_mdl,brain_mdl))
print("")


### brain*position model:
#scaled brain
print(sprintf("%s, scaled BRAIN BY POSITION, Rep%d %s",roi,r,subRep1_ttl))
brain_and_pos_mdl=glmer(scaled_RT_pooled ~ scaled_brain_bysubj + fac_pos + sc_TrialOrderAll + fac_list + (1|subID),data = curr_data, family = inverse.gaussian(link = 'identity')) #, control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))

brain_by_pos_mdl=glmer(scaled_RT_pooled ~ scaled_brain_bysubj*fac_pos + sc_TrialOrderAll + fac_list + (1|subID),data = curr_data, family = inverse.gaussian(link = 'identity')) #, control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000))

print(anova(brain_and_pos_mdl,brain_by_pos_mdl))
print("")

#scaled brain
print(sprintf("%s, scaled BRAIN BY POSITION, without temporal order, Rep%d %s",roi,r,subRep1_ttl))
#this one did not converge w/o bobyqa:
brain_and_pos_mdl=glmer(scaled_RT_pooled ~ scaled_brain_bysubj + fac_pos + fac_list + (1|subID),data = curr_data, family = inverse.gaussian(link = 'identity'), control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

brain_by_pos_mdl=glmer(scaled_RT_pooled ~ scaled_brain_bysubj*fac_pos + fac_list + (1|subID),data = curr_data, family = inverse.gaussian(link = 'identity'), control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

print(anova(brain_and_pos_mdl,brain_by_pos_mdl))
print("")

# #unscaled brain
# print(sprintf("%s, UNscaled BRAIN BY POSITION, Rep%d %s, %s",roi,whichRep,subRep1_ttl,csf_ttl))
# brain_and_pos_mdl=glmer(scaled_RT_pooled ~ UNscaled_brain + fac_pos + sc_TrialOrderAll + fac_list + (1|subID),data = curr_data, family = inverse.gaussian(link = 'identity'), control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))
# 
# brain_by_pos_mdl=glmer(scaled_RT_pooled ~  UNscaled_brain*fac_pos + sc_TrialOrderAll + fac_list + (1|subID),data = curr_data, family = inverse.gaussian(link = 'identity'), control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))
# 
# print(anova(brain_and_pos_mdl,brain_by_pos_mdl))
# print("")


###### each position separately
all_pos=unique(curr_data$fac_pos)
for (curr_pos in all_pos) {
  
  curr_pos_data <- filter(curr_data, curr_data$fac_pos == curr_pos)
  curr_pos_data <- filter(curr_pos_data,!(is.na(curr_pos_data$scaled_brain_bysubj)))
  
  null_mdl=glmer(scaled_RT_pooled ~ sc_TrialOrderAll + fac_list +  (1|subID),data = curr_pos_data, family = inverse.gaussian(link = 'identity'),control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))
  
  #scaled brain:
  print(sprintf("%s, scaled BRAIN, cue-target sim, cue pos %s, Rep%d %s",roi,curr_pos,r,subRep1_ttl))
  brain_mdl=glmer(scaled_RT_pooled ~ scaled_brain_bysubj + sc_TrialOrderAll + fac_list +  (1|subID),data = curr_pos_data, family = inverse.gaussian(link = 'identity'), control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))
  
  print(anova(null_mdl,brain_mdl))
  print("")
  
}
 
```
# ANTERIOR and POSTERIOR: Interaction btw rois
### grab the data
```{r analyse entire simMAT}

#list of files - these are all the regions:
analysis_reg= "hipp"  
#rep1 removed:
allfiles <- list.files(path = paste(results_dir, "/results/encoding/rsa/regions_data/", sep="/"), pattern = sprintf("%s*",analysis_reg), all.files = FALSE, full.names = TRUE, recursive = FALSE)

#temporary for JNeuro ant/post in temp folder:
curr_all_files=allfiles
regs=c(5,6,7,8) #lant,lpost,rant,rpost

#main analysis:
#take only simMAT:
#curr_all_files=allfiles[seq(3,length(allfiles), by = 3)]
#lca23_025: 13
#ldg_025: 16
#rca23_025: 23
#rdg_025: 26

#hack to initiate an empty frame:
#all_reg_data <- model_simMAT[FALSE,FALSE]

#regs=c(13,16,23,26)
for (reg in regs ) {
curr_file=curr_all_files[reg]
fname = basename(curr_file)
#get the roi: substr(get_data$roi,regexpr('HATA_', get_data$roi)+5,nchar(get_data$roi))
roi <- substr(fname,regexpr('HATA_', fname)+5,regexpr('_simMat', fname)-1) #get the roi name
hemi <- substr(fname,9,9)
print(sprintf("roi is %s, hemi is %s ",roi, hemi))

#get the data
brain_data <- read.table(curr_file, header = TRUE,sep = "\t",dec = ".")
curr_data <- bind_cols(model_simMAT, brain_data)

#remove NA:
curr_data <- filter(curr_data, !is.na(curr_data$thirdTR))

curr_data$reg_name <- roi
curr_data$hemi <- hemi
if (reg == 5) { #(reg == 13) just bc the first one in the loop
  all_reg_data <- curr_data
} else {
  all_reg_data <- bind_rows(all_reg_data, curr_data)
}

} #ends the loop for rois
 
```
### analyse the interaction
```{r analyse the interaction}

#event_mdl_control time - within is 2, across is 1
curr_data <- filter(all_reg_data, all_reg_data$wa_control_time != 0)

#if excluding rep1:
curr_data <- filter(curr_data, curr_data$repetition > 1)

#this is currently reported in dissertation chapter, with all repetitions:
null_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name + fac_wa_control_time*hemi + hemi*reg_name + gap + fac_list + (1|subID),curr_data,REML=F)

full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name*hemi+ gap + fac_list + (1|subID),curr_data,REML=F)
#this tests the triple interaction:
drop1(full_mdl,test = "Chi")
#this tests each of the 2-way interactions
drop1(null_mdl,test = "Chi") #this doesn't give the Chi value

#redo to test each of the 2-way interactions revealed sig:
null_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name + hemi*reg_name + gap + fac_list + (1|subID),curr_data,REML=F)

full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name + fac_wa_control_time*hemi + hemi*reg_name + gap + fac_list + (1|subID),curr_data,REML=F)

print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))

###
null_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name + hemi*reg_name + gap + fac_list + (1|subID),curr_data,REML=F)

full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name + fac_wa_control_time*hemi + hemi*reg_name + gap + fac_list + (1|subID),curr_data,REML=F)

print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))

#has an interaction of event by roi by hemi, so examine each hemi separately:
for (hemis in c('r','l')) {
  d=curr_data[curr_data$hemi == hemis,]
  
  null_mdl=lmer(thirdTR ~ fac_wa_control_time + reg_name+ gap + fac_list + (1|subID),d,REML=F)

  full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name+ gap + fac_list + (1|subID),d,REML=F)
  
  print(sprintf("#### event * roi for %s hemi: ####",hemis))
  
  #summary(full_mdl)
  print(anova(full_mdl,null_mdl))
  AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
  print(sprintf("AIC diff: %.2f",AIC_diff))

}

#these analyses in each hemi revealed an interaction in the left hemi, nothing in the right hemi. so further analyses were limited to the left hemi - see next chunk.

#in Rep5, we wanted to establish that the event*roi is sig:
d=curr_data[curr_data$hemi == 'l',]
curr_rep_data <- filter(d, d$repetition == 5)

null_mdl=lmer(thirdTR ~ fac_wa_control_time + reg_name + gap + fac_list + (1|subID),curr_rep_data,REML=F)

full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name + gap + fac_list + (1|subID),curr_rep_data,REML=F)

summary(full_mdl)
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))

#by the way, the gap*event*roi is not:
null_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name + fac_wa_control_time*gap + gap*reg_name + fac_list + (1|subID),curr_rep_data,REML=F)

full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name*gap + fac_list + (1|subID),curr_rep_data,REML=F)

summary(full_mdl)
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))

## additional analyses, currently not reported:
#this is the interaction with repetition - works as well, but I don't think we need it to distinguish between hemispheres. I only report the one above, without repetition
full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name*hemi*repetition + fac_list + (1|subID),curr_data,REML=F)
drop1(full_mdl,test = "Chi")

# only 5th repetition: This also works.
curr_rep_data <- filter(curr_data, curr_data$repetition == 5)

null_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name + fac_wa_control_time*hemi + hemi*reg_name + fac_list + (1|subID),curr_rep_data,REML=F)

full_mdl=lmer(thirdTR ~ fac_wa_control_time*reg_name*hemi + fac_list + (1|subID),curr_rep_data,REML=F)

summary(full_mdl)
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
 
```

# analysis per ROI:
### grab the data
```{r grab the data}
#set up:
subtract_Rep1 <- 0

analysis_reg = "hipp" 

reg=8 #(5-8)
model= 'filtered100s_mtc_clean_mc_wmcsf_3sphere'

#results_dir <- sprintf("/Volumes/data/Bein/Repatime/repatime_scanner/results/encoding/rsa/no_smooth/%s/voxel_removed/FilesForR_outlier_corr_removed",model)

#subtract tep1 or not
if (subtract_Rep1 == 1) {
allfiles <- list.files(path = paste(results_dir, "/results/encoding/rsa/regions_data", sep="/"), pattern = sprintf("%s*",analysis_reg), all.files = FALSE, full.names = TRUE, recursive = FALSE)

#set up the title
subRep1_ttl <- 'minus Rep1'

} else {
#this is without subtracting the first rep:
  reg <- reg-4
allfiles <- list.files(path = paste(results_dir, "/results/encoding/rsa/regions_data_noRep1Subtraction", sep="/"), pattern = sprintf("%s*",analysis_reg), all.files = FALSE, full.names = TRUE, recursive = FALSE)

#set up the title
subRep1_ttl <- ''
}

#take only simMAT:
#curr_all_files=allfiles[seq(3,length(allfiles), by = 4)]
curr_file=allfiles[reg]

fname = basename(curr_file)

#get the roi:
roi=substr(fname,regexpr('fs_', fname)+3,regexpr('_simMat', fname)-1) #get the roi name


#get the data
brain_data <- read.table(curr_file, header = TRUE,sep = "\t",dec = ".")
curr_data <- bind_cols(model_simMAT, brain_data)

#remove NA:
curr_data <- filter(curr_data, !is.na(curr_data$thirdTR))

#scale brain data within subject:
curr_data <- curr_data %>%
   mutate(scaled_brain_bysubj = scale_by(curr_data$thirdTR ~ subID))

#save a copy:
all_data <- curr_data #just to keep some copy of that, in case we mess up with things later on

#plot the correlations:
b1 <- ggplot(all_data, aes(x=all_data$thirdTR)) + 
  geom_histogram() + 
  theme_bw() +
  labs(y = 'similarity', title ='all values')
 
curr_data <- filter(all_data, all_data$wa_control_time != 0)
 
#plot the correlations:
b2 <- ggplot(curr_data, aes(x=curr_data$thirdTR)) + 
  geom_histogram() + 
  theme_bw() +
  labs(y = 'similarity', title ='control gap values')

grid.arrange(b1, b2,ncol=2)

print(sprintf("roi is %s, %s",roi, model))


```

### temporal gap/event models - w/o response in the models
```{r temporal gap/event models}

#for dg we did more gap analyses, not needed for CA3:
analyze_gap <- 0

reps=c() #c(5) #empty if don't want to run reps
#########################
curr_data$curr_gap <- curr_data$gap
curr_data$curr_brain  <- curr_data$thirdTR

#if want to exclude rep1
#curr_data <- filter(curr_data, curr_data$repetition != 1)


###### models ######
print(sprintf("########### analysis for %s %s #############",roi,subRep1_ttl))

if (subtract_Rep1 == 1) {
#event model control for gap: we have different number of items per gap, important to control for that:
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_data,REML=F)

print(sprintf("event model, controling for gap %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#gap, controling for events: we have different number of items per gap, important to control for that:
null_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_data,REML=F)

print(sprintf("gap, controling for event %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


#gap and event interaction:
null_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time * curr_gap + fac_list + (1|subID),curr_data,REML=F)

print(sprintf("gap by event interaction %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

} else {

#event by repetition
#that's reported for CA3:
null_mdl=lmer(curr_brain ~ fac_wa_control_time + repetition + curr_gap + fac_list + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time*repetition + curr_gap + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("event by repetition interaction, gap in the model %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#gap by repetition
#that's reported for CA1:
null_mdl=lmer(curr_brain ~ fac_wa_control_time + repetition + curr_gap + fac_list + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time + repetition * curr_gap + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("gap by repetition interaction,event in the model %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#event_mdl_control time by temporal gap by repetition - within is 2, across is 1
#that's reported for DG:
null_mdl=lmer(curr_brain ~ fac_wa_control_time*curr_gap+curr_gap*repetition + fac_wa_control_time*repetition + fac_list + (1|subID),curr_data,REML=F)
full_mdl=lmer(curr_brain ~ fac_wa_control_time*curr_gap*repetition + fac_list + (1|subID),curr_data,REML=F)
print(sprintf("gap by event by repetition interaction %s", roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

}

# #only WITHIN - all gaps
# curr_onlyWithOrAc_data <- filter(curr_data , curr_data$wa_control_time  == 2)
# null_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_onlyWithOrAc_data,REML=F)
# print(sprintf("only WITHIN, check the intercept %s",roi))
# print(summary(null_mdl))
# 
# #only ACROSS - all gaps
# curr_onlyWithOrAc_data <- filter(curr_data , curr_data$wa_control_time  == 1)
# null_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_onlyWithOrAc_data,REML=F)
# print(sprintf("only ACROSS, check the intercept  %s",roi))
# print(summary(null_mdl))


if (analyze_gap == 1) {
onlyWithOrAc_data <- filter(curr_data , curr_data$wa_control_time  == 2)
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),onlyWithOrAc_data,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),onlyWithOrAc_data,REML=F)
print(sprintf("only WITHIN, main effect of gap, %s", roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

onlyWithOrAc_data <- filter(curr_data , curr_data$wa_control_time  == 1)
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),onlyWithOrAc_data,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),onlyWithOrAc_data,REML=F)
print(sprintf("only ACROSS, main effect of gap, %s", roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")
}


for ( r in reps) {
print(sprintf("################# rep %d ####################",r))
curr_rep_data <- filter(curr_data,curr_data$repetition == r)

null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_rep_data,REML=F)
print(sprintf("REP %d: event_mdl %s",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#event model control for gap: we have different number of items per gap, important to control for that: *this is reported for CA3*
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)

print(sprintf("REP %d: event_mdl controling for gap %s",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#gap, controling for events: we have different number of items per gap, important to control for that:
null_mdl=lmer(curr_brain ~ fac_wa_control_time + fac_list + (1|subID),curr_rep_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)

print(sprintf("REP %d: gap, controling for event %s",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#gap and event interaction:
null_mdl=lmer(curr_brain ~ fac_wa_control_time + curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)

full_mdl=lmer(curr_brain ~ fac_wa_control_time * curr_gap + fac_list + (1|subID),curr_rep_data,REML=F)

print(sprintf("REP %d: gap by event interaction %s",r, roi))
print(anova(full_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(full_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#only WITHIN - all gaps
curr_rep_onlyWithOrAc_data <- filter(curr_rep_data , curr_rep_data$wa_control_time  == 2)
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
print(sprintf("only WITHIN, check the intercept rep %d, %s",r, roi))
print(summary(null_mdl))

#only ACROSS - all gaps
curr_rep_onlyWithOrAc_data <- filter(curr_rep_data , curr_rep_data$wa_control_time  == 1)
null_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
print(sprintf("only ACROSS, check the intercept rep %d, %s",r, roi))
print(summary(null_mdl))

if (analyze_gap == 1) {
#only WITHIN - all gaps
curr_rep_onlyWithOrAc_data <- filter(curr_rep_data , curr_rep_data$wa_control_time  == 2)

null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
print(sprintf("only WITHIN, main effect of gap, rep %d, %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")


#only within - gaps 1-2
curr_rep_selgap <- filter(curr_rep_onlyWithOrAc_data ,
                                  curr_rep_onlyWithOrAc_data$gap  < 3)
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_selgap,REML=F)
print(sprintf("only WITHIN, gap 1-2, rep %d,  %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#only within - gaps 1-3
curr_rep_selgap <- filter(curr_rep_onlyWithOrAc_data ,
                                  curr_rep_onlyWithOrAc_data$gap  != 2)
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_selgap,REML=F)
print(sprintf("only WITHIN, gap 1-3, rep %d,  %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#only ACROSS - all gaps
curr_rep_onlyWithOrAc_data <- filter(curr_rep_data , curr_rep_data$wa_control_time  == 1)

null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_onlyWithOrAc_data,REML=F)
print(sprintf("only ACROSS, main effect of gap, rep %d, %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#only ACROSS - gaps 1-2
curr_rep_selgap <- filter(curr_rep_onlyWithOrAc_data ,
                                  curr_rep_onlyWithOrAc_data$gap  < 3)
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_selgap,REML=F)
print(sprintf("only ACROSS, gap 1-2, rep %d,  %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

#only ACROSS - gaps 1-3
curr_rep_selgap <- filter(curr_rep_onlyWithOrAc_data ,
                                  curr_rep_onlyWithOrAc_data$gap  != 2)
null_mdl=lmer(curr_brain ~ fac_list + (1|subID),curr_rep_selgap,REML=F)
gap_mdl=lmer(curr_brain ~ curr_gap + fac_list + (1|subID),curr_rep_selgap,REML=F)
print(sprintf("only ACROSS, gap 1-3, rep %d,  %s",r, roi))
print(anova(gap_mdl,null_mdl))
AIC_diff <- (extractAIC(null_mdl)[2] - extractAIC(gap_mdl)[2])
print(sprintf("AIC diff: %.2f",AIC_diff))
print("")

} #end the analyse_gap

} #end the repetition


```

### plot similarity events/gap (supp figures)
```{r plot gap from entire simMAT}
##### set up ploting:

all_spectral<-brewer.pal(11,"RdYlBu")
myspec_within <-all_spectral[c(2,3,4)]
#myspec_across <-all_spectral[c(10,9,8)] #blues
all_spectral<-brewer.pal(9,"Greys")
myspec_across <-all_spectral[c(4,5,6)] #greys
myspec <-c(myspec_across[2],myspec_within[2])

#plot event by gap by rep - don't plot rep1
labels_rep <- c(
  "1" = "Repetition 1",
  "2" = "Repetition 2",
  "3" = "Repetition 3",
  "4" = "Repetition 4",
  "5" = "Repetition 5"
)

labels_gap <- c(
  "1" = "Gap1",
  "2" = "Gap2",
  "3" = "Gap3"
)

labels_wa <- c(
  "1" = "across",
  "2" = "within"
)

#### #set up data:
subtract_Rep1 <- 1

analysis_reg = "hipp" 
model= 'filtered100s_mtc_clean_mc_wmcsf_3sphere'

#results_dir <- sprintf("/Volumes/data/Bein/Repatime/repatime_scanner/results/encoding/rsa/no_smooth/%s/voxel_removed/FilesForR_outlier_corr_removed",model)

#subtract tep1 or not
if (subtract_Rep1 == 1) {
allfiles <- list.files(path = paste(results_dir, "/results/encoding/rsa/regions_data", sep="/"), pattern = sprintf("%s*",analysis_reg), all.files = FALSE, full.names = TRUE, recursive = FALSE)

#set up the title
subRep1_ttl <- 'minus Rep1'

} else {
#this is without subtracting the first rep:
allfiles <- list.files(path = paste(results_dir, "/results/encoding/rsa/regions_data_noRep1Subtraction", sep="/"), pattern = sprintf("%s*",analysis_reg), all.files = FALSE, full.names = TRUE, recursive = FALSE)

#set up the title
subRep1_ttl <- ''
}

#loop through ROIs
regs=c(5,6,7,8)
for (reg in regs) { #(1-4)

#take only simMAT:
#curr_all_files=allfiles[seq(3,length(allfiles), by = 4)]
curr_file=allfiles[reg]

fname = basename(curr_file)

#get the roi:
roi=substr(fname,regexpr('fs_', fname)+3,regexpr('_simMat', fname)-1) #get the roi name


#get the data
brain_data <- read.table(curr_file, header = TRUE,sep = "\t",dec = ".")
curr_data <- bind_cols(model_simMAT, brain_data)

#remove NA:
curr_data <- filter(curr_data, !is.na(curr_data$thirdTR))

#scale brain data within subject:
curr_data <- curr_data %>%
   mutate(scaled_brain_bysubj = scale_by(curr_data$thirdTR ~ subID))


#plot only control time:
data_wa_control_time <- filter(curr_data, curr_data$wa_control_time != 0)



########### actually plot things ###########
summary_gap_event_model_control_time_rep <- data_wa_control_time %>%
  group_by(subID, gap, fac_wa_control_time, repetition ) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE))
summary_gap_event_model_control_time_rep$fac_gap <- factor(summary_gap_event_model_control_time_rep$gap)

#this fig. is in the supp

all_reps_p <- ggplot(summary_gap_event_model_control_time_rep, aes(x = gap, y = mean_sim)) +
stat_summary(data = summary_gap_event_model_control_time_rep, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
labs(x = 'Temporal Distance', y = sprintf('Similarity %s', subRep1_ttl),title = roi) +
scale_color_manual(values = myspec) +
facet_grid(~repetition) + 
theme_all_gaps +theme(legend.position = "none",
                  axis.title.x = element_blank(),
                  axis.title.y = element_blank(),
                  strip.text.x = element_blank()) #remove repetition titles:


#print(all_reps_p)

if (reg == 5) {
  lant_p <- all_reps_p
} else if (reg == 6) {
  lpost_p <- all_reps_p
} else if (reg == 7) {
  rant_p <- all_reps_p
} else if (reg == 8) {
  rpost_p <- all_reps_p
}

#remove rep1 and average across reps:
data_wa_control_time_no_rep1 <- filter(data_wa_control_time, data_wa_control_time$repetition != 1)
summary_gap_event_model_control_time <- data_wa_control_time_no_rep1 %>%
  group_by(subID, gap, fac_wa_control_time) %>%
  summarize(mean_sim = mean(thirdTR, na.rm = TRUE))

average_reps_p <- ggplot(summary_gap_event_model_control_time, aes(x = gap, y = mean_sim)) +
stat_summary(data = summary_gap_event_model_control_time, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
labs(x = 'Temporal Distance', y = sprintf('Similarity %s', subRep1_ttl),title = roi) +
scale_color_manual(values = myspec) +
theme_all_gaps +theme(legend.position = "none",
                  axis.title.x = element_blank(),
                  axis.title.y = element_blank())


if (reg == 5) {
  lant_av_p <- average_reps_p
} else if (reg == 6) {
  lpost_av_p <- average_reps_p
} else if (reg == 7) {
  rant_av_p <- average_reps_p
} else if (reg == 8) {
  rpost_av_p <- average_reps_p
}


}

grid.arrange(lant_p,lpost_p,rant_p,rpost_p,nrow = 4)

grid.arrange(lant_av_p,rant_av_p,lpost_av_p,rpost_av_p,nrow = 2)

#coord_cartesian(ylim = c(-.018,.023)) +
#this fig is for the main figures:
rep5 <- ggplot(summary_gap_event_model_control_time_rep5, aes(x = gap, y = mean_sim)) +
  stat_summary(data = summary_gap_event_model_control_time_rep5, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
  labs(x = 'Gap', y = 'Similarity (Rep5 minus Rep1)',) +
  scale_color_manual(values = myspec) +
  scale_x_continuous(breaks = c(1,2,3),labels=c(0,1,2)) +
  theme_gap + theme(legend.position = "none") 

print(rep5)

#for CA3, only within vs, across:
rep5_wa <- ggplot(summary_only_event_model_control_time_rep5, aes(x = 1, y = mean_sim)) +
  stat_summary(data = summary_only_event_model_control_time_rep5, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
  labs(y = 'Similarity (Rep5 minus Rep1)') +
  scale_color_manual(values = myspec) +
  coord_cartesian(ylim = c(-.012,.012)) +
  scale_x_continuous(breaks = c(1,2,3),labels=c(0,1,2)) +
  theme_classic() + theme(legend.position = "none",
                    axis.title.x = element_blank(),
                    axis.text.x = element_blank(),
                    axis.ticks.x = element_blank(),
                    axis.line.x = element_blank(),
                    axis.title.y = element_text(size = 16)) 

#for CA3, only within vs, across with subj data points:
# geom_violin(data = data_wa_diff_per_subj,aes(x = "1", y = wa_diff, alpha = .4))
plt_CA3_subj_con <- ggplot(data_wa_diff_per_subj, aes(x = 1, y = wa_diff, color = "1")) +
  stat_summary(data = data_wa_diff_per_subj, fun.data = mean_se_, geom = "pointrange",aes(color = "1"), position_dodge(width = .9),size=1) +
  geom_hline(yintercept=0, colour="black", linetype = "dotted") +
  xlim(0.7,1.3) +
  geom_jitter(width = .08,size = 2,shape = 1) + 
  scale_color_manual(values = myspec[2]) +
  labs(y = 'Similarity\n(within > across)') + 
  theme_classic() + theme(legend.position = "none",
                          axis.title.x = element_blank(),
                          axis.text.x = element_blank(),
                          axis.line.x = element_blank(),
                          axis.ticks.x = element_blank(),
                          axis.title.y = element_text(size = 16))

grid.arrange(rep5_wa,plt_CA3_subj_con,widths = c(1.8,1),ncol = 2)

#for DG - show the spread of the interaction 
plt_DG_subj_con <- ggplot(data_only_g1g3, aes(x = fac_wa_control_time, y = g1g3_diff, color = fac_wa_control_time)) +
  geom_hline(yintercept=0, colour="black", linetype = "dotted") +
  stat_summary(data = data_only_g1g3, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
  geom_jitter(width = .15,size = 2,shape = 1) + 
  scale_color_manual(values = myspec) +
  labs(y = 'Temporal separation\n(temporal distance 1 minus 3)') + 
  theme_classic() + theme(legend.position = "none",
                          axis.title.x = element_blank(),
                          axis.text.x = element_blank(),
                          axis.line.x = element_blank(),
                          axis.ticks.x = element_blank(),
                          axis.title.y = element_text(size = 14))

#grid.arrange(rep5,plt_DG_subj_con,widths = c(1.8,1),ncol = 2)


#stat_summary(data = data_only_g1g3, fun.data = mean_se_, geom = "pointrange",aes(x = fac_wa_control_time, y = g1g3_diff, color = fac_wa_control_time), position_dodge(width = .9),size=1) +
  #geom_jitter(width = .08,size = 2,shape = 1) + 
 # geom_point() + geom_line() +

#for DG - show the spread of the interaction - this is me starting to do something with connecting the dots...:
#doesn't look too good...
data_only_g1g3_jit <- data_only_g1g3 %>%
  mutate(jit_wa = jitter(as.numeric(fac_wa_control_time),amount = .1))
plt_DG_subj_con <- ggplot(data_only_g1g3_jit, aes(x = jit_wa, y = g1g3_diff, color = fac_wa_control_time)) +
  geom_hline(yintercept=0, colour="black", linetype = "dotted") +
  scale_color_manual(values = myspec) +
  geom_path(aes(group = factor(subID)), color='grey',size=0.4) +
  geom_point(size = 2,shape = 1) +
  labs(y = 'Temporal separation\n(temporal distance 1 minus 3)') + 
  theme_classic() + theme(legend.position = "none",
                          axis.title.x = element_blank(),
                          #axis.text.x = element_blank(),
                          #axis.line.x = element_blank(),
                          #axis.ticks.x = element_blank(),
                          axis.title.y = element_text(size = 14))

#additional data plots:
rep5_with_subj_dots <- ggplot(summary_gap_event_model_control_time_rep5, aes(x = gap, y = mean_sim)) +
  stat_summary(data = summary_gap_event_model_control_time_rep5, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
  geom_point(aes(color = fac_wa_control_time), position = position_jitterdodge(dodge.width = 0.9), alpha = .8,size=2) +
  labs(x = 'Temporal Distance', y = 'Similarity (Rep5 minus Rep1)') +
  scale_color_manual(values = myspec) +
  theme_gap + theme(legend.position = "none") 


#geom_hline(yintercept=0, color="black", linetype = "dotted") +
all_reps_p_by_wa <- ggplot(summary_gap_event_model_control_time_rep, aes(x = repetition, y = mean_sim,color = fac_wa_control_time, alpha = fac_gap)) + 
  stat_summary(data = summary_gap_event_model_control_time_rep, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time,alpha = fac_gap), position_dodge(width = .9),size=1) +
  labs(x = 'Repetition', y = 'similarity (thirdTR)', title = roi) +
  scale_alpha_discrete(range = c(1,0.4),
                       name=NULL,
                       breaks=c("1", "2","3"),
                       labels=c("Gap1","Gap2","Gap3")) +
  scale_color_manual(values = myspec,
                       name=NULL,
                       breaks=c("1", "2"),
                       labels=c("across-events","within-event")) +
  facet_grid(~fac_wa_control_time,labeller = labeller(fac_wa_control_time = labels_wa)) + 
  theme_all_gaps + theme(legend.position = NULL)
print(all_reps_p_by_wa)

#just plot gap:
# all_reps_gap <- ggplot(summary_gap_event_model_control_time_rep, aes(x = gap, y = mean_sim)) +
#   stat_summary(data = summary_gap_event_model_control_time_rep, fun.data = mean_se_, geom = "pointrange",aes(color = fac_wa_control_time), position_dodge(width = .9),size=1) +
#   labs(x = 'Gap', y = 'Similarity (Diff. from Rep1)') +
#   scale_color_manual(values = myspec) +
#   scale_x_continuous(breaks = c(1,2,3),labels=c(0,1,2)) +
#   facet_grid(~repetition,labeller = labeller(repetition = labels_rep)) + 
#   theme_all_gaps + theme(legend.position = "none") 
# 
# print(all_reps_p)
```
